# Story 1.3: User Registration API

## Status
Draft

## Story
**As a** user,
**I want** to create an account with my email and password,
**so that** I can save my progress and access personalized learning features.

## Acceptance Criteria
1. POST `/api/auth/register` endpoint accepts `email` and `password` in request body
2. Email validation: Must be valid email format, unique in database (return 409 Conflict if duplicate)
3. Password validation: Minimum 8 characters, must contain at least one letter and one number
4. Password hashed using bcrypt or Argon2 before storage (never store plaintext)
5. User record created in `users` table with hashed password
6. Response returns user object (id, email, created_at) and JWT token with 7-day expiration
7. JWT token includes user_id in payload for authentication
8. Error responses: 400 Bad Request for validation errors, 409 Conflict for duplicate email, 500 Internal Server Error for database issues
9. Unit tests: Valid registration, duplicate email, weak password, invalid email format
10. Integration test: Full registration flow creates user in database and returns valid JWT

## Tasks / Subtasks

- [ ] **Task 1: Install Authentication Dependencies** (AC: 4, 6)
  - [ ] Add to `requirements.txt`: `bcrypt==4.1.x`, `PyJWT==2.8.x`, `python-jose[cryptography]==3.3.x`
  - [ ] Add `passlib` for bcrypt integration: `passlib[bcrypt]==1.7.x`
  - [ ] Verify dependencies install successfully

- [ ] **Task 2: Create Authentication Utilities** (AC: 4, 6, 7)
  - [ ] Create `apps/api/src/utils/auth.py`
  - [ ] Implement `hash_password(password: str) -> str` using bcrypt with cost factor 12
  - [ ] Implement `verify_password(plain: str, hashed: str) -> bool` for password verification
  - [ ] Implement `create_access_token(data: dict, expires_delta: timedelta) -> str` for JWT generation
  - [ ] Add JWT configuration to `apps/api/src/config.py`: SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_DAYS
  - [ ] Add JWT environment variables to `.env.example`

- [ ] **Task 3: Create User Repository** (AC: 2, 5)
  - [ ] Create `apps/api/src/repositories/user_repository.py`
  - [ ] Implement `async def create_user(email: str, hashed_password: str) -> User` method
  - [ ] Implement `async def get_by_email(email: str) -> User | None` method
  - [ ] Implement `async def get_by_id(user_id: UUID) -> User | None` method
  - [ ] Use async SQLAlchemy sessions from Story 1.2
  - [ ] Handle database exceptions appropriately

- [ ] **Task 4: Create Authentication Service** (AC: 2, 4, 5, 6, 7)
  - [ ] Create `apps/api/src/services/auth_service.py`
  - [ ] Implement `async def register_user(email: str, password: str) -> tuple[User, str]`
  - [ ] Check if email already exists (raise ConflictError if duplicate)
  - [ ] Hash password using `hash_password()` utility
  - [ ] Create user via user_repository
  - [ ] Generate JWT token with user_id in payload and 7-day expiration
  - [ ] Return (user, token) tuple

- [ ] **Task 5: Create Custom Exception Classes** (AC: 8)
  - [ ] Create `apps/api/src/exceptions.py`
  - [ ] Define `ConflictError` exception (409 status)
  - [ ] Define `ValidationError` exception (400 status)
  - [ ] Define `DatabaseError` exception (500 status)
  - [ ] Ensure exceptions include message and optional details

- [ ] **Task 6: Create Global Exception Handler** (AC: 8)
  - [ ] Create `apps/api/src/middleware/error_handler.py`
  - [ ] Implement FastAPI exception handlers for custom exceptions
  - [ ] Return error responses matching architecture format: `{error: {code, message, details, timestamp, request_id}}`
  - [ ] Generate unique request_id (UUID) for each request
  - [ ] Include timestamp in ISO 8601 format
  - [ ] Register exception handlers in `main.py`

- [ ] **Task 7: Create Registration Endpoint** (AC: 1, 2, 3, 6, 8)
  - [ ] Create `apps/api/src/routes/auth.py`
  - [ ] Define `POST /v1/auth/register` endpoint
  - [ ] Accept `UserCreate` Pydantic schema (from Story 1.2) in request body
  - [ ] Call `auth_service.register_user()`
  - [ ] Return `UserResponse` and JWT token in response
  - [ ] Handle exceptions and return appropriate error responses
  - [ ] Register auth router in `main.py` with `/v1` prefix

- [ ] **Task 8: Create Response Schema for Registration** (AC: 6)
  - [ ] Update `apps/api/src/schemas/auth.py`
  - [ ] Define `RegisterResponse` schema with `user: UserResponse` and `token: str` fields
  - [ ] Define `TokenData` schema for JWT payload structure
  - [ ] Ensure all schemas have proper documentation

- [ ] **Task 9: Write Unit Tests** (AC: 9)
  - [ ] Create `apps/api/tests/unit/test_auth_utils.py`
  - [ ] Test `hash_password()` produces different hashes for same password
  - [ ] Test `verify_password()` correctly validates passwords
  - [ ] Test `create_access_token()` generates valid JWT with correct payload and expiration
  - [ ] Create `apps/api/tests/unit/test_auth_service.py`
  - [ ] Test registration with valid email and password
  - [ ] Test registration with duplicate email (mock repository)
  - [ ] Test password validation failures (weak password, too short)
  - [ ] Test email validation failures (invalid format)

- [ ] **Task 10: Write Integration Tests** (AC: 10)
  - [ ] Create `apps/api/tests/integration/test_auth_api.py`
  - [ ] Test full registration flow: POST request → user created in database → valid JWT returned
  - [ ] Test duplicate email returns 409 Conflict
  - [ ] Test invalid email format returns 400 Bad Request
  - [ ] Test weak password returns 400 Bad Request
  - [ ] Verify user record exists in database after successful registration
  - [ ] Verify JWT token can be decoded and contains correct user_id
  - [ ] Verify password is hashed (not plaintext) in database

- [ ] **Task 11: Update API Documentation** (AC: 1)
  - [ ] Ensure FastAPI auto-docs show registration endpoint at `/docs`
  - [ ] Add docstrings to endpoint with description and examples
  - [ ] Document request/response schemas
  - [ ] Test Swagger UI for registration endpoint

## Dev Notes

### Previous Story Context

From **Story 1.1** (relevant learnings):
- Backend structure: `apps/api/src/` with routes, services, repositories, models, schemas, middleware, utils
- FastAPI application entry point: `apps/api/src/main.py`

From **Story 1.2** (relevant learnings):
- User model already created with: id (UUID), email, hashed_password, created_at, updated_at, and onboarding fields
- `UserCreate` Pydantic schema already has email and password validation
- `UserResponse` Pydantic schema excludes password_hash
- Database session factory `get_db()` available for dependency injection
- PostgreSQL database configured with users table
- Test database infrastructure ready

### API Endpoint Specification

**Endpoint:** `POST /v1/auth/register` [Source: architecture/api-specification.md]

**Base URL:**
- Development: `http://localhost:8000/v1`
- Production: `https://api.learnr.com/v1`

**Request Schema:**
```json
{
  "email": "user@example.com",
  "password": "SecurePass123"
}
```

**Success Response (201 Created):**
```json
{
  "user": {
    "id": "uuid-here",
    "email": "user@example.com",
    "created_at": "2025-11-21T10:30:00Z",
    "exam_date": null,
    "target_score": null,
    "daily_study_time": null,
    "knowledge_level": null,
    "motivation": null,
    "referral_source": null,
    "is_admin": false,
    "dark_mode": "auto"
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**Error Response Format:** [Source: architecture/error-handling-strategy.md]
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email format",
    "details": { "field": "email" },
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

### Password Hashing Configuration

**Technology:** bcrypt with cost factor 12 [Source: architecture/security-and-performance.md#Authentication Security]

**Implementation:**
```python
# apps/api/src/utils/auth.py
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """
    Hash password using bcrypt with cost factor 12.

    Args:
        password: Plain text password

    Returns:
        Hashed password string
    """
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify password against hashed version.

    Args:
        plain_password: Plain text password to verify
        hashed_password: Hashed password from database

    Returns:
        True if password matches, False otherwise
    """
    return pwd_context.verify(plain_password, hashed_password)
```

### JWT Token Configuration

**Token Expiration:** 7 days (per Epic AC) [Source: Epic 1.3 AC #6]

⚠️ **NOTE:** The security-and-performance.md document mentions 15-minute access tokens and 7-day refresh tokens, but Epic 1.3 specifies 7-day token expiration. For MVP simplicity (matching Epic requirements), implement single 7-day token. Token refresh (Story 1.6 mentions "not implemented in MVP") will be added in future stories if needed.

**JWT Configuration:**
```python
# apps/api/src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # JWT Configuration
    JWT_SECRET_KEY: str  # From environment
    JWT_ALGORITHM: str = "HS256"
    JWT_ACCESS_TOKEN_EXPIRE_DAYS: int = 7

    class Config:
        env_file = ".env"

settings = Settings()
```

**Environment Variables:**
```bash
# apps/api/.env.example
JWT_SECRET_KEY=your-secret-key-min-32-chars-generate-with-openssl-rand-hex-32
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_DAYS=7
```

**Token Generation Implementation:**
```python
# apps/api/src/utils/auth.py
from datetime import datetime, timedelta
from jose import jwt
from apps.api.src.config import settings

def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
    """
    Create JWT access token.

    Args:
        data: Payload data (must include 'sub' for user_id)
        expires_delta: Optional custom expiration delta

    Returns:
        Encoded JWT token string
    """
    to_encode = data.copy()

    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(days=settings.JWT_ACCESS_TOKEN_EXPIRE_DAYS)

    to_encode.update({
        "exp": expire,
        "iat": datetime.utcnow()
    })

    encoded_jwt = jwt.encode(
        to_encode,
        settings.JWT_SECRET_KEY,
        algorithm=settings.JWT_ALGORITHM
    )

    return encoded_jwt
```

**JWT Payload Structure:** [Source: architecture/backend-architecture.md#Authentication]
```json
{
  "sub": "user_id_uuid",
  "exp": 1732790400,
  "iat": 1732186800
}
```

### Repository Pattern Implementation

[Source: architecture/backend-architecture.md#Repository Pattern]

```python
# apps/api/src/repositories/user_repository.py
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from uuid import UUID
from apps.api.src.models.user import User
from apps.api.src.exceptions import ConflictError, DatabaseError

class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create_user(self, email: str, hashed_password: str) -> User:
        """
        Create new user in database.

        Args:
            email: User email (unique)
            hashed_password: bcrypt-hashed password

        Returns:
            Created User model

        Raises:
            ConflictError: If email already exists
            DatabaseError: If database operation fails
        """
        user = User(
            email=email.lower(),  # Normalize email to lowercase
            hashed_password=hashed_password
        )

        try:
            self.session.add(user)
            await self.session.commit()
            await self.session.refresh(user)
            return user
        except IntegrityError as e:
            await self.session.rollback()
            if "unique constraint" in str(e).lower():
                raise ConflictError(f"Email {email} already registered")
            raise DatabaseError("Failed to create user")

    async def get_by_email(self, email: str) -> User | None:
        """
        Get user by email address.

        Args:
            email: User email

        Returns:
            User model if found, None otherwise
        """
        result = await self.session.execute(
            select(User).where(User.email == email.lower())
        )
        return result.scalar_one_or_none()

    async def get_by_id(self, user_id: UUID) -> User | None:
        """
        Get user by ID.

        Args:
            user_id: User UUID

        Returns:
            User model if found, None otherwise
        """
        result = await self.session.execute(
            select(User).where(User.id == user_id)
        )
        return result.scalar_one_or_none()
```

### Service Layer Implementation

```python
# apps/api/src/services/auth_service.py
from datetime import timedelta
from uuid import UUID
from apps.api.src.repositories.user_repository import UserRepository
from apps.api.src.utils.auth import hash_password, create_access_token
from apps.api.src.models.user import User
from apps.api.src.exceptions import ConflictError
from apps.api.src.config import settings

class AuthService:
    def __init__(self, user_repo: UserRepository):
        self.user_repo = user_repo

    async def register_user(self, email: str, password: str) -> tuple[User, str]:
        """
        Register new user account.

        Args:
            email: User email (validated by Pydantic)
            password: Plain text password (validated by Pydantic)

        Returns:
            Tuple of (User model, JWT token)

        Raises:
            ConflictError: If email already exists
        """
        # Check if user already exists
        existing_user = await self.user_repo.get_by_email(email)
        if existing_user:
            raise ConflictError(f"Email {email} already registered")

        # Hash password
        hashed_password = hash_password(password)

        # Create user
        user = await self.user_repo.create_user(email, hashed_password)

        # Generate JWT token
        access_token = create_access_token(
            data={"sub": str(user.id)},
            expires_delta=timedelta(days=settings.JWT_ACCESS_TOKEN_EXPIRE_DAYS)
        )

        return user, access_token
```

### Exception Handling

**Custom Exceptions:**
```python
# apps/api/src/exceptions.py
class AppException(Exception):
    """Base exception for application errors."""
    def __init__(self, message: str, details: dict = None):
        self.message = message
        self.details = details or {}
        super().__init__(self.message)

class ConflictError(AppException):
    """Raised when resource conflict occurs (409)."""
    pass

class ValidationError(AppException):
    """Raised when validation fails (400)."""
    pass

class DatabaseError(AppException):
    """Raised when database operation fails (500)."""
    pass
```

**Global Exception Handler:**
```python
# apps/api/src/middleware/error_handler.py
from fastapi import Request, status
from fastapi.responses import JSONResponse
from datetime import datetime
import uuid
from apps.api.src.exceptions import ConflictError, ValidationError, DatabaseError

async def conflict_error_handler(request: Request, exc: ConflictError):
    """Handle 409 Conflict errors."""
    return JSONResponse(
        status_code=status.HTTP_409_CONFLICT,
        content={
            "error": {
                "code": "CONFLICT_ERROR",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

async def validation_error_handler(request: Request, exc: ValidationError):
    """Handle 400 Bad Request errors."""
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={
            "error": {
                "code": "VALIDATION_ERROR",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

async def database_error_handler(request: Request, exc: DatabaseError):
    """Handle 500 Internal Server Error."""
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": {
                "code": "DATABASE_ERROR",
                "message": "An internal error occurred",
                "details": {},
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

# Register in main.py:
# app.add_exception_handler(ConflictError, conflict_error_handler)
# app.add_exception_handler(ValidationError, validation_error_handler)
# app.add_exception_handler(DatabaseError, database_error_handler)
```

### Registration Endpoint Implementation

```python
# apps/api/src/routes/auth.py
from fastapi import APIRouter, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession
from apps.api.src.schemas.user import UserCreate, UserResponse
from apps.api.src.schemas.auth import RegisterResponse
from apps.api.src.services.auth_service import AuthService
from apps.api.src.repositories.user_repository import UserRepository
from apps.api.src.db.session import get_db

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post(
    "/register",
    response_model=RegisterResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register new user account",
    description="Create a new user account with email and password. Returns user object and JWT token."
)
async def register(
    user_data: UserCreate,
    db: AsyncSession = Depends(get_db)
):
    """
    Register new user account.

    - **email**: Valid email address (unique)
    - **password**: Minimum 8 characters, must contain letter and number

    Returns user object (without password) and JWT token with 7-day expiration.
    """
    # Initialize repository and service
    user_repo = UserRepository(db)
    auth_service = AuthService(user_repo)

    # Register user
    user, token = await auth_service.register_user(user_data.email, user_data.password)

    # Return response
    return RegisterResponse(
        user=UserResponse.from_orm(user),
        token=token
    )
```

**Register router in main.py:**
```python
# apps/api/src/main.py
from fastapi import FastAPI
from apps.api.src.routes import auth
from apps.api.src.middleware.error_handler import (
    conflict_error_handler,
    validation_error_handler,
    database_error_handler
)
from apps.api.src.exceptions import ConflictError, ValidationError, DatabaseError

app = FastAPI(title="LearnR API", version="1.0.0")

# Register exception handlers
app.add_exception_handler(ConflictError, conflict_error_handler)
app.add_exception_handler(ValidationError, validation_error_handler)
app.add_exception_handler(DatabaseError, database_error_handler)

# Register routers with /v1 prefix
app.include_router(auth.router, prefix="/v1")

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

### Pydantic Schema for Registration Response

```python
# apps/api/src/schemas/auth.py
from pydantic import BaseModel
from apps.api.src.schemas.user import UserResponse

class RegisterResponse(BaseModel):
    """Response schema for user registration."""
    user: UserResponse
    token: str

    class Config:
        schema_extra = {
            "example": {
                "user": {
                    "id": "123e4567-e89b-12d3-a456-426614174000",
                    "email": "user@example.com",
                    "created_at": "2025-11-21T10:30:00Z",
                    "exam_date": None,
                    "target_score": None,
                    "daily_study_time": None,
                    "knowledge_level": None,
                    "motivation": None,
                    "referral_source": None,
                    "is_admin": False,
                    "dark_mode": "auto"
                },
                "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
            }
        }

class TokenData(BaseModel):
    """JWT token payload structure."""
    sub: str  # user_id
    exp: int  # expiration timestamp
    iat: int  # issued at timestamp
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Unit Tests (apps/api/tests/unit/):**

```python
# tests/unit/test_auth_utils.py
import pytest
from apps.api.src.utils.auth import hash_password, verify_password, create_access_token
from datetime import timedelta
from jose import jwt
from apps.api.src.config import settings

def test_hash_password_produces_different_hashes():
    """Test that same password produces different hashes."""
    password = "TestPass123"
    hash1 = hash_password(password)
    hash2 = hash_password(password)
    assert hash1 != hash2  # bcrypt includes random salt

def test_verify_password_success():
    """Test password verification with correct password."""
    password = "TestPass123"
    hashed = hash_password(password)
    assert verify_password(password, hashed) is True

def test_verify_password_failure():
    """Test password verification with incorrect password."""
    password = "TestPass123"
    hashed = hash_password(password)
    assert verify_password("WrongPass456", hashed) is False

def test_create_access_token():
    """Test JWT token creation with correct payload."""
    user_id = "123e4567-e89b-12d3-a456-426614174000"
    token = create_access_token(data={"sub": user_id})

    # Decode token
    payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])

    assert payload["sub"] == user_id
    assert "exp" in payload
    assert "iat" in payload

def test_create_access_token_custom_expiration():
    """Test JWT token with custom expiration."""
    user_id = "123e4567-e89b-12d3-a456-426614174000"
    token = create_access_token(
        data={"sub": user_id},
        expires_delta=timedelta(days=1)
    )

    payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
    assert payload["sub"] == user_id
```

**Integration Tests (apps/api/tests/integration/):**

```python
# tests/integration/test_auth_api.py
import pytest
from httpx import AsyncClient
from apps.api.src.main import app
from apps.api.src.db.session import get_db
from jose import jwt
from apps.api.src.config import settings

@pytest.mark.asyncio
async def test_register_success(async_client: AsyncClient, db_session):
    """Test successful user registration."""
    response = await async_client.post(
        "/v1/auth/register",
        json={
            "email": "test@example.com",
            "password": "SecurePass123"
        }
    )

    assert response.status_code == 201
    data = response.json()

    # Verify response structure
    assert "user" in data
    assert "token" in data
    assert data["user"]["email"] == "test@example.com"
    assert "id" in data["user"]
    assert "hashed_password" not in data["user"]  # Password not exposed

    # Verify JWT token
    token = data["token"]
    payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
    assert payload["sub"] == data["user"]["id"]

@pytest.mark.asyncio
async def test_register_duplicate_email(async_client: AsyncClient, db_session):
    """Test registration with duplicate email returns 409."""
    # Register first user
    await async_client.post(
        "/v1/auth/register",
        json={"email": "duplicate@example.com", "password": "SecurePass123"}
    )

    # Try to register again with same email
    response = await async_client.post(
        "/v1/auth/register",
        json={"email": "duplicate@example.com", "password": "DifferentPass456"}
    )

    assert response.status_code == 409
    data = response.json()
    assert "error" in data
    assert data["error"]["code"] == "CONFLICT_ERROR"

@pytest.mark.asyncio
async def test_register_invalid_email(async_client: AsyncClient):
    """Test registration with invalid email returns 400."""
    response = await async_client.post(
        "/v1/auth/register",
        json={"email": "not-an-email", "password": "SecurePass123"}
    )

    assert response.status_code == 422  # Pydantic validation error
    # Note: FastAPI returns 422 for Pydantic validation errors by default

@pytest.mark.asyncio
async def test_register_weak_password(async_client: AsyncClient):
    """Test registration with weak password returns 400."""
    response = await async_client.post(
        "/v1/auth/register",
        json={"email": "test@example.com", "password": "short"}  # Only 5 chars
    )

    assert response.status_code == 422  # Pydantic validation error

@pytest.mark.asyncio
async def test_register_password_no_number(async_client: AsyncClient):
    """Test password without number fails validation."""
    response = await async_client.post(
        "/v1/auth/register",
        json={"email": "test@example.com", "password": "NoNumberPass"}
    )

    assert response.status_code == 422

@pytest.mark.asyncio
async def test_user_created_in_database(async_client: AsyncClient, db_session):
    """Test user record is actually created in database."""
    response = await async_client.post(
        "/v1/auth/register",
        json={"email": "dbtest@example.com", "password": "SecurePass123"}
    )

    assert response.status_code == 201

    # Query database directly
    from apps.api.src.repositories.user_repository import UserRepository
    user_repo = UserRepository(db_session)
    user = await user_repo.get_by_email("dbtest@example.com")

    assert user is not None
    assert user.email == "dbtest@example.com"
    assert user.hashed_password.startswith("$2b$")  # bcrypt hash prefix

@pytest.mark.asyncio
async def test_password_is_hashed(async_client: AsyncClient, db_session):
    """Test password is hashed, not stored as plaintext."""
    password = "SecurePass123"
    response = await async_client.post(
        "/v1/auth/register",
        json={"email": "hashtest@example.com", "password": password}
    )

    # Query database
    from apps.api.src.repositories.user_repository import UserRepository
    user_repo = UserRepository(db_session)
    user = await user_repo.get_by_email("hashtest@example.com")

    # Verify password is NOT plaintext
    assert user.hashed_password != password
    assert len(user.hashed_password) == 60  # bcrypt hash length
```

### Coding Standards Reminders

[Source: architecture/coding-standards.md]

- **Async/Await:** All database and API operations must use async/await
- **Error Handling:** All API routes must use standard error handler middleware
- **Database Access:** Never write raw SQL - use SQLAlchemy ORM and repository pattern exclusively
- **Naming:** Functions use snake_case in Python

### Dependencies to Add

```txt
# Add to apps/api/requirements.txt
bcrypt==4.1.2
PyJWT==2.8.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
```

### Success Criteria Checklist

Before marking this story complete, verify:
1. ✓ POST `/v1/auth/register` endpoint exists and returns 201 on success
2. ✓ Email validation works (invalid format returns 422)
3. ✓ Duplicate email returns 409 Conflict
4. ✓ Password validation works (< 8 chars or no number returns 422)
5. ✓ Password is hashed with bcrypt (verify in database)
6. ✓ User record created in database with all fields
7. ✓ JWT token returned with 7-day expiration
8. ✓ JWT token contains user_id in "sub" claim
9. ✓ Error responses match architecture format (code, message, details, timestamp, request_id)
10. ✓ All unit tests pass (auth utils, password hashing, JWT creation)
11. ✓ All integration tests pass (full registration flow, duplicate email, weak password)
12. ✓ FastAPI auto-docs show registration endpoint at `/docs`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
