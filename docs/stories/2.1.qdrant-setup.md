# Story 2.1: Qdrant Vector Database Setup

## Status
Draft

## Story
**As a** backend developer,
**I want** to set up Qdrant locally via Docker and create collections for questions and reading content,
**so that** semantic search and content retrieval can function.

## Acceptance Criteria
1. Qdrant Docker container running locally (docker-compose.yml or standalone docker run command)
2. Qdrant accessible at `localhost:6333` with REST API and gRPC
3. Two collections created:
   - `cbap_questions`: Vector size 3072 (text-embedding-3-large), distance metric: Cosine
   - `babok_chunks`: Vector size 3072, distance metric: Cosine
4. Collection schemas include metadata fields (payload):
   - Questions: `question_id`, `ka`, `difficulty`, `concept_tags`, `question_text`, `options`, `correct_answer`
   - BABOK chunks: `chunk_id`, `ka`, `section_ref`, `difficulty`, `concept_tags`, `text_content`
5. Qdrant Python client installed and configured in backend
6. Connection test: Backend can create, read, update, delete (CRUD) vectors in both collections
7. Environment variable `QDRANT_URL` configurable (default: `http://localhost:6333`)
8. README documents Qdrant setup commands and how to verify collections exist
9. Qdrant data persisted to local volume (survives container restart)
10. Health check extended to verify Qdrant connectivity

## Tasks / Subtasks

- [ ] **Task 1: Add Qdrant to Docker Compose** (AC: 1, 2, 9)
  - [ ] Update `infrastructure/docker/docker-compose.yml`
  - [ ] Add Qdrant service with image `qdrant/qdrant:1.7.4`
  - [ ] Expose ports: 6333 (REST API) and 6334 (gRPC)
  - [ ] Configure persistent volume for data storage
  - [ ] Add healthcheck command
  - [ ] Test: `docker-compose up qdrant` starts successfully
  - [ ] Verify Qdrant web UI accessible at `http://localhost:6333/dashboard`

- [ ] **Task 2: Install Qdrant Python Client** (AC: 5)
  - [ ] Add to `apps/api/requirements.txt`: `qdrant-client==1.7.x`
  - [ ] Install dependency
  - [ ] Verify import works: `from qdrant_client import QdrantClient`

- [ ] **Task 3: Configure Qdrant Connection** (AC: 5, 7)
  - [ ] Add Qdrant configuration to `apps/api/src/config.py`
  - [ ] Add environment variables: QDRANT_URL, QDRANT_API_KEY (optional for local)
  - [ ] Create `apps/api/src/db/qdrant_client.py` with async client initialization
  - [ ] Add connection lifecycle management (startup/shutdown hooks)
  - [ ] Add QDRANT_URL to `.env.example`

- [ ] **Task 4: Create Collection Initialization Script** (AC: 3, 4)
  - [ ] Create `apps/api/scripts/init_qdrant_collections.py`
  - [ ] Define `cbap_questions` collection schema:
    - [ ] Vector size: 3072 dimensions
    - [ ] Distance metric: Cosine
    - [ ] Payload schema: question_id (keyword), ka (keyword), difficulty (keyword), concept_tags (keyword[]), question_text (text), options (text), correct_answer (keyword)
  - [ ] Define `babok_chunks` collection schema:
    - [ ] Vector size: 3072 dimensions
    - [ ] Distance metric: Cosine
    - [ ] Payload schema: chunk_id (keyword), ka (keyword), section_ref (keyword), difficulty (keyword), concept_tags (keyword[]), text_content (text)
  - [ ] Script creates collections if they don't exist (idempotent)
  - [ ] Script logs collection creation status

- [ ] **Task 5: Create Qdrant Repository** (AC: 6)
  - [ ] Create `apps/api/src/repositories/qdrant_repository.py`
  - [ ] Implement `async def create_question_vector(question_id, vector, payload)`
  - [ ] Implement `async def get_question_vector(question_id)`
  - [ ] Implement `async def search_questions(query_vector, filters, limit)`
  - [ ] Implement `async def delete_question_vector(question_id)`
  - [ ] Implement similar methods for BABOK chunks
  - [ ] Handle Qdrant exceptions appropriately

- [ ] **Task 6: Write CRUD Tests** (AC: 6)
  - [ ] Create `apps/api/tests/integration/test_qdrant.py`
  - [ ] Test create vector in cbap_questions collection
  - [ ] Test read vector from collection
  - [ ] Test search vectors with filters (by KA, difficulty)
  - [ ] Test update vector payload
  - [ ] Test delete vector
  - [ ] Test same operations for babok_chunks collection
  - [ ] Use test Qdrant instance or collection cleanup between tests

- [ ] **Task 7: Extend Health Check** (AC: 10)
  - [ ] Update `apps/api/src/routes/health.py`
  - [ ] Add Qdrant connectivity check
  - [ ] Test: Get Qdrant collections count
  - [ ] Include Qdrant status in health response
  - [ ] Return 503 if Qdrant is unavailable
  - [ ] Add response time measurement

- [ ] **Task 8: Update Documentation** (AC: 8)
  - [ ] Update `apps/api/README.md` with Qdrant setup section
  - [ ] Document how to start Qdrant: `docker-compose up qdrant`
  - [ ] Document how to access Qdrant web UI
  - [ ] Document how to run collection initialization script
  - [ ] Document how to verify collections exist (API endpoints or web UI)
  - [ ] Add troubleshooting section for common Qdrant issues

- [ ] **Task 9: Create Qdrant Utility Functions** (AC: 6)
  - [ ] Create `apps/api/src/utils/qdrant_utils.py`
  - [ ] Implement helper for building filter conditions
  - [ ] Implement helper for pagination
  - [ ] Implement helper for similarity score interpretation
  - [ ] Add logging for Qdrant operations

- [ ] **Task 10: Verify Collection Configuration** (AC: 3, 4)
  - [ ] Run initialization script
  - [ ] Verify collections exist in Qdrant web UI
  - [ ] Verify vector size and distance metric are correct
  - [ ] Verify payload schema is indexed properly
  - [ ] Test insert sample vector and query it back

## Dev Notes

### Previous Story Context

From **Epic 1** (relevant learnings):
- Docker Compose for local infrastructure (PostgreSQL, Redis)
- Environment variable management patterns
- Health check endpoint pattern
- Repository pattern for data access

### ⚠️ CRITICAL VECTOR DIMENSION CORRECTION

**EPIC DISCREPANCY:** Epic 2.1 AC #3 specifies vector size 1536, but this is **incorrect**.

**Correct Specification:** [Source: architecture/tech-stack.md#Technology Stack Table]
- Model: `text-embedding-3-large`
- Vector dimensions: **3072** (not 1536)
- Vector size 1536 is for `text-embedding-3-small` or `text-embedding-ada-002`

**Implementation:** Use 3072 dimensions for all collections as specified in architecture.

### Qdrant Service Configuration

**Qdrant Version:** 1.7.x [Source: architecture/tech-stack.md#Technology Stack Table]

**Docker Compose Configuration:**

```yaml
# infrastructure/docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    # Existing PostgreSQL service from Epic 1...

  redis:
    # Existing Redis service from Epic 1...

  qdrant:
    image: qdrant/qdrant:1.7.4
    container_name: learnr-qdrant
    ports:
      - "6333:6333"  # REST API
      - "6334:6334"  # gRPC
    volumes:
      - qdrant_storage:/qdrant/storage
    environment:
      - QDRANT_LOG_LEVEL=INFO
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/health"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  qdrant_storage:
```

**Start Qdrant:**
```bash
docker-compose up -d qdrant
```

**Verify Qdrant is running:**
```bash
curl http://localhost:6333/health
# Expected: {"title":"qdrant - vector search engine","version":"1.7.4"}
```

**Access Qdrant Web UI:**
```
http://localhost:6333/dashboard
```

### Qdrant Python Client Configuration

**Installation:**
```txt
# apps/api/requirements.txt
qdrant-client==1.7.4
```

**Configuration:**
```python
# apps/api/src/config.py
class Settings(BaseSettings):
    # Existing config...

    # Qdrant Configuration
    QDRANT_URL: str = "http://localhost:6333"
    QDRANT_API_KEY: str | None = None  # For Qdrant Cloud
    QDRANT_TIMEOUT: int = 10  # Seconds

    class Config:
        env_file = ".env"
```

**Environment Variables:**
```bash
# apps/api/.env.example
# Qdrant Vector Database
QDRANT_URL=http://localhost:6333
QDRANT_API_KEY=  # Leave empty for local, set for Qdrant Cloud
QDRANT_TIMEOUT=10
```

**Async Client Initialization:**
```python
# apps/api/src/db/qdrant_client.py
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams
from apps.api.src.config import settings
import logging

logger = logging.getLogger(__name__)

qdrant_client: QdrantClient = None

def get_qdrant() -> QdrantClient:
    """Get Qdrant client instance."""
    global qdrant_client
    if qdrant_client is None:
        qdrant_client = QdrantClient(
            url=settings.QDRANT_URL,
            api_key=settings.QDRANT_API_KEY,
            timeout=settings.QDRANT_TIMEOUT
        )
        logger.info(f"Qdrant client initialized: {settings.QDRANT_URL}")
    return qdrant_client

def close_qdrant():
    """Close Qdrant client connection."""
    global qdrant_client
    if qdrant_client:
        qdrant_client.close()
        qdrant_client = None
        logger.info("Qdrant client closed")

# Register lifecycle hooks in main.py:
# @app.on_event("startup")
# async def startup():
#     get_qdrant()
#
# @app.on_event("shutdown")
# async def shutdown():
#     close_qdrant()
```

### Collection Schemas

**CBAP Questions Collection:** [Source: Epic 2.1 AC #4]

```python
# apps/api/scripts/init_qdrant_collections.py
from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams, PayloadSchemaType, FieldCondition
from apps.api.src.config import settings

def init_collections():
    """Initialize Qdrant collections for questions and BABOK chunks."""
    client = QdrantClient(url=settings.QDRANT_URL)

    # Collection 1: CBAP Questions
    questions_collection = "cbap_questions"

    # Check if collection exists
    collections = client.get_collections().collections
    collection_names = [col.name for col in collections]

    if questions_collection not in collection_names:
        client.create_collection(
            collection_name=questions_collection,
            vectors_config=VectorParams(
                size=3072,  # text-embedding-3-large dimensions
                distance=Distance.COSINE
            )
        )

        # Create payload indexes for filtering
        client.create_payload_index(
            collection_name=questions_collection,
            field_name="question_id",
            field_schema=PayloadSchemaType.KEYWORD
        )
        client.create_payload_index(
            collection_name=questions_collection,
            field_name="ka",
            field_schema=PayloadSchemaType.KEYWORD
        )
        client.create_payload_index(
            collection_name=questions_collection,
            field_name="difficulty",
            field_schema=PayloadSchemaType.KEYWORD
        )
        client.create_payload_index(
            collection_name=questions_collection,
            field_name="concept_tags",
            field_schema=PayloadSchemaType.KEYWORD
        )

        print(f"✓ Created collection: {questions_collection}")
    else:
        print(f"Collection {questions_collection} already exists")

    # Collection 2: BABOK Chunks
    babok_collection = "babok_chunks"

    if babok_collection not in collection_names:
        client.create_collection(
            collection_name=babok_collection,
            vectors_config=VectorParams(
                size=3072,  # text-embedding-3-large dimensions
                distance=Distance.COSINE
            )
        )

        # Create payload indexes for filtering
        client.create_payload_index(
            collection_name=babok_collection,
            field_name="chunk_id",
            field_schema=PayloadSchemaType.KEYWORD
        )
        client.create_payload_index(
            collection_name=babok_collection,
            field_name="ka",
            field_schema=PayloadSchemaType.KEYWORD
        )
        client.create_payload_index(
            collection_name=babok_collection,
            field_name="section_ref",
            field_schema=PayloadSchemaType.KEYWORD
        )
        client.create_payload_index(
            collection_name=babok_collection,
            field_name="difficulty",
            field_schema=PayloadSchemaType.KEYWORD
        )

        print(f"✓ Created collection: {babok_collection}")
    else:
        print(f"Collection {babok_collection} already exists")

    # Verify collections
    info = client.get_collection(collection_name=questions_collection)
    print(f"\nQuestions Collection Info:")
    print(f"  Vectors: {info.vectors_count}")
    print(f"  Vector size: {info.config.params.vectors.size}")
    print(f"  Distance: {info.config.params.vectors.distance}")

    info = client.get_collection(collection_name=babok_collection)
    print(f"\nBABOK Chunks Collection Info:")
    print(f"  Vectors: {info.vectors_count}")
    print(f"  Vector size: {info.config.params.vectors.size}")
    print(f"  Distance: {info.config.params.vectors.distance}")

if __name__ == "__main__":
    init_collections()
```

**Run initialization:**
```bash
python apps/api/scripts/init_qdrant_collections.py
```

### Qdrant Repository Pattern

```python
# apps/api/src/repositories/qdrant_repository.py
from qdrant_client import QdrantClient
from qdrant_client.models import PointStruct, Filter, FieldCondition, MatchValue
from uuid import UUID
from typing import List, Dict, Any
import logging

from apps.api.src.db.qdrant_client import get_qdrant

logger = logging.getLogger(__name__)

class QdrantRepository:
    def __init__(self):
        self.client = get_qdrant()

    # Question Methods

    async def create_question_vector(
        self,
        question_id: UUID,
        vector: List[float],
        payload: Dict[str, Any]
    ) -> None:
        """
        Insert question vector into Qdrant.

        Args:
            question_id: Question UUID
            vector: 3072-dimensional embedding vector
            payload: Metadata (question_id, ka, difficulty, concept_tags, question_text, options, correct_answer)
        """
        point = PointStruct(
            id=str(question_id),
            vector=vector,
            payload=payload
        )

        self.client.upsert(
            collection_name="cbap_questions",
            points=[point]
        )

        logger.info(f"Created question vector: {question_id}")

    async def get_question_vector(self, question_id: UUID) -> Dict[str, Any] | None:
        """
        Retrieve question vector by ID.

        Args:
            question_id: Question UUID

        Returns:
            Point with vector and payload, or None if not found
        """
        result = self.client.retrieve(
            collection_name="cbap_questions",
            ids=[str(question_id)]
        )

        if result:
            return result[0]
        return None

    async def search_questions(
        self,
        query_vector: List[float],
        filters: Dict[str, Any] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Semantic search for questions.

        Args:
            query_vector: 3072-dimensional query embedding
            filters: Optional filters (ka, difficulty, concept_tags)
            limit: Maximum results to return

        Returns:
            List of matching questions with similarity scores
        """
        # Build filter conditions
        filter_conditions = None
        if filters:
            must_conditions = []

            if "ka" in filters:
                must_conditions.append(
                    FieldCondition(
                        key="ka",
                        match=MatchValue(value=filters["ka"])
                    )
                )

            if "difficulty" in filters:
                must_conditions.append(
                    FieldCondition(
                        key="difficulty",
                        match=MatchValue(value=filters["difficulty"])
                    )
                )

            if must_conditions:
                filter_conditions = Filter(must=must_conditions)

        # Search
        results = self.client.search(
            collection_name="cbap_questions",
            query_vector=query_vector,
            query_filter=filter_conditions,
            limit=limit
        )

        return [
            {
                "id": result.id,
                "score": result.score,
                "payload": result.payload
            }
            for result in results
        ]

    async def delete_question_vector(self, question_id: UUID) -> None:
        """Delete question vector from Qdrant."""
        self.client.delete(
            collection_name="cbap_questions",
            points_selector=[str(question_id)]
        )

        logger.info(f"Deleted question vector: {question_id}")

    # BABOK Chunk Methods (similar pattern)

    async def create_chunk_vector(
        self,
        chunk_id: UUID,
        vector: List[float],
        payload: Dict[str, Any]
    ) -> None:
        """Insert BABOK chunk vector into Qdrant."""
        point = PointStruct(
            id=str(chunk_id),
            vector=vector,
            payload=payload
        )

        self.client.upsert(
            collection_name="babok_chunks",
            points=[point]
        )

        logger.info(f"Created chunk vector: {chunk_id}")

    async def search_chunks(
        self,
        query_vector: List[float],
        filters: Dict[str, Any] = None,
        limit: int = 3
    ) -> List[Dict[str, Any]]:
        """Semantic search for BABOK chunks."""
        filter_conditions = None
        if filters and "ka" in filters:
            filter_conditions = Filter(
                must=[
                    FieldCondition(
                        key="ka",
                        match=MatchValue(value=filters["ka"])
                    )
                ]
            )

        results = self.client.search(
            collection_name="babok_chunks",
            query_vector=query_vector,
            query_filter=filter_conditions,
            limit=limit
        )

        return [
            {
                "id": result.id,
                "score": result.score,
                "payload": result.payload
            }
            for result in results
        ]
```

### Health Check Extension

```python
# apps/api/src/routes/health.py
# Add Qdrant check to existing health endpoint

from apps.api.src.db.qdrant_client import get_qdrant

@router.get("/health", response_model=HealthResponse)
async def health_check(db: AsyncSession = Depends(get_db)):
    """
    Health check endpoint for monitoring.

    Verifies:
    - API is running
    - Database connection is healthy
    - Qdrant connection is healthy  # NEW
    """
    timestamp = datetime.utcnow().isoformat() + "Z"

    # Database check (existing from Epic 1)
    # ...

    # Qdrant check (NEW)
    qdrant_status = "unknown"
    qdrant_response_time_ms = None

    try:
        qdrant_client = get_qdrant()
        start_time = time.time()

        # Verify connection by getting collections
        collections = qdrant_client.get_collections()
        qdrant_response_time_ms = int((time.time() - start_time) * 1000)
        qdrant_status = "connected"

    except Exception as e:
        logger.error(f"Qdrant health check failed: {str(e)}")
        qdrant_status = "disconnected"

    # Return health response with both database and Qdrant status
    if database_status == "connected" and qdrant_status == "connected":
        return HealthResponse(
            status="healthy",
            timestamp=timestamp,
            database=DatabaseHealth(...),
            qdrant=QdrantHealth(
                status=qdrant_status,
                response_time_ms=qdrant_response_time_ms,
                collections_count=len(collections.collections)
            )
        )
    else:
        # Return 503 if any service is down
        # ...
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Integration Tests:**

```python
# tests/integration/test_qdrant.py
import pytest
from uuid import uuid4
from apps.api.src.repositories.qdrant_repository import QdrantRepository

@pytest.fixture
def qdrant_repo():
    """Create Qdrant repository instance."""
    return QdrantRepository()

@pytest.fixture
def sample_question_vector():
    """Generate sample 3072-dimensional vector."""
    return [0.1] * 3072  # Dummy vector for testing

@pytest.mark.asyncio
async def test_create_question_vector(qdrant_repo, sample_question_vector):
    """Test creating question vector in Qdrant."""
    question_id = uuid4()
    payload = {
        "question_id": str(question_id),
        "ka": "Business Analysis Planning and Monitoring",
        "difficulty": "Medium",
        "concept_tags": ["planning", "stakeholder"],
        "question_text": "What is stakeholder analysis?",
        "options": "A) ... B) ... C) ... D) ...",
        "correct_answer": "A"
    }

    await qdrant_repo.create_question_vector(question_id, sample_question_vector, payload)

    # Verify creation
    result = await qdrant_repo.get_question_vector(question_id)
    assert result is not None
    assert result.payload["ka"] == "Business Analysis Planning and Monitoring"

    # Cleanup
    await qdrant_repo.delete_question_vector(question_id)

@pytest.mark.asyncio
async def test_search_questions_with_filters(qdrant_repo, sample_question_vector):
    """Test searching questions with KA filter."""
    # Create test question
    question_id = uuid4()
    payload = {
        "question_id": str(question_id),
        "ka": "Elicitation and Collaboration",
        "difficulty": "Hard",
        "concept_tags": ["elicitation"],
        "question_text": "Test question",
        "options": "Options",
        "correct_answer": "B"
    }

    await qdrant_repo.create_question_vector(question_id, sample_question_vector, payload)

    # Search with filter
    results = await qdrant_repo.search_questions(
        query_vector=sample_question_vector,
        filters={"ka": "Elicitation and Collaboration"},
        limit=10
    )

    assert len(results) >= 1
    assert results[0]["payload"]["ka"] == "Elicitation and Collaboration"

    # Cleanup
    await qdrant_repo.delete_question_vector(question_id)

@pytest.mark.asyncio
async def test_delete_question_vector(qdrant_repo, sample_question_vector):
    """Test deleting question vector."""
    question_id = uuid4()
    payload = {"question_id": str(question_id), "ka": "Test"}

    # Create
    await qdrant_repo.create_question_vector(question_id, sample_question_vector, payload)

    # Delete
    await qdrant_repo.delete_question_vector(question_id)

    # Verify deletion
    result = await qdrant_repo.get_question_vector(question_id)
    assert result is None
```

### Coding Standards Reminders

[Source: architecture/coding-standards.md]

- **Async Operations:** All Qdrant operations should use async patterns where possible
- **Error Handling:** Handle Qdrant connection errors gracefully
- **Logging:** Log Qdrant operations for debugging and monitoring

### Dependencies to Add

```txt
# Add to apps/api/requirements.txt
qdrant-client==1.7.4
```

### Success Criteria Checklist

Before marking this story complete, verify:
1. ✓ Qdrant Docker container running and accessible at localhost:6333
2. ✓ Qdrant web UI accessible at http://localhost:6333/dashboard
3. ✓ Collections created with 3072 vector dimensions (not 1536!)
4. ✓ Payload indexes created for filtering (ka, difficulty, concept_tags)
5. ✓ Qdrant Python client installed and importable
6. ✓ Connection configuration in config.py and .env.example
7. ✓ CRUD operations work (create, read, search, delete vectors)
8. ✓ Data persists after container restart (volume configured)
9. ✓ Health check includes Qdrant connectivity status
10. ✓ README documents Qdrant setup and verification steps
11. ✓ Integration tests pass for both collections
12. ✓ Collection initialization script is idempotent

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
