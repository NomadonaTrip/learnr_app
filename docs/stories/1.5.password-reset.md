# Story 1.5: Password Reset Flow

## Status
Draft

## Story
**As a** user who forgot my password,
**I want** to reset my password via email verification,
**so that** I can regain access to my account securely.

## Acceptance Criteria
1. POST `/api/auth/forgot-password` endpoint accepts `email`
2. Generate secure password reset token (UUID or similar, 1-hour expiration)
3. Store reset token in database with expiration timestamp (new `password_reset_tokens` table or add to `users`)
4. Send password reset email with reset link: `https://app.learnr.com/reset-password?token={token}`
5. Email sent even if email not found (prevent email enumeration, but no token created)
6. POST `/api/auth/reset-password` endpoint accepts `token` and `new_password`
7. Token validation: Exists, not expired, not already used
8. Password validation: Same rules as registration (8+ chars, letter + number)
9. Update user password (hash new password), invalidate reset token
10. Return success message (no JWT - user must log in with new password)
11. Unit tests: Valid reset, expired token, invalid token, weak new password
12. Integration test: Full password reset flow from forgot to login with new password

## Tasks / Subtasks

- [ ] **Task 1: Install Email Dependencies** (AC: 4)
  - [ ] Add to `requirements.txt`: `sendgrid==6.11.x`, `python-decouple==3.8` (for API key management)
  - [ ] Add email configuration to `apps/api/src/config.py`: SENDGRID_API_KEY, FROM_EMAIL, FRONTEND_URL
  - [ ] Add email environment variables to `.env.example`
  - [ ] Verify SendGrid API key works with test send

- [ ] **Task 2: Create Password Reset Tokens Table** (AC: 2, 3)
  - [ ] Decide on storage approach: separate `password_reset_tokens` table (recommended for auditability and cleanup)
  - [ ] Create SQLAlchemy model `apps/api/src/models/password_reset_token.py`
  - [ ] Define fields: id (UUID), user_id (FK), token (UUID, unique), created_at, expires_at, used_at (nullable)
  - [ ] Add indexes: unique on token, index on user_id, index on expires_at
  - [ ] Generate Alembic migration: `alembic revision --autogenerate -m "Add password reset tokens table"`
  - [ ] Apply migration: `alembic upgrade head`

- [ ] **Task 3: Create Password Reset Token Repository** (AC: 2, 3, 7, 9)
  - [ ] Create `apps/api/src/repositories/password_reset_repository.py`
  - [ ] Implement `async def create_token(user_id: UUID, expires_in_hours: int = 1) -> PasswordResetToken`
  - [ ] Implement `async def get_valid_token(token: str) -> PasswordResetToken | None` (checks not expired, not used)
  - [ ] Implement `async def mark_token_used(token: str) -> None`
  - [ ] Implement `async def invalidate_user_tokens(user_id: UUID) -> None` (invalidate all previous tokens on reset)

- [ ] **Task 4: Create Email Service** (AC: 4, 5)
  - [ ] Create `apps/api/src/services/email_service.py`
  - [ ] Implement SendGrid client initialization
  - [ ] Implement `async def send_password_reset_email(email: str, reset_token: str) -> bool`
  - [ ] Create email template with reset link: `{FRONTEND_URL}/reset-password?token={token}`
  - [ ] Handle SendGrid errors gracefully (log but don't expose to user)
  - [ ] Return True on success, False on failure (for logging)

- [ ] **Task 5: Create Password Reset Schemas** (AC: 1, 6, 8)
  - [ ] Update `apps/api/src/schemas/auth.py`
  - [ ] Define `ForgotPasswordRequest` schema with email field
  - [ ] Define `ForgotPasswordResponse` schema with success message
  - [ ] Define `ResetPasswordRequest` schema with token and new_password fields
  - [ ] Define `ResetPasswordResponse` schema with success message
  - [ ] Add password validation to ResetPasswordRequest (reuse from UserCreate)

- [ ] **Task 6: Add Password Reset Methods to Auth Service** (AC: 2, 3, 4, 5, 7, 8, 9, 10)
  - [ ] Update `apps/api/src/services/auth_service.py`
  - [ ] Implement `async def request_password_reset(email: str) -> None`
  - [ ] Look up user by email (case-insensitive)
  - [ ] If user exists: create reset token, send email
  - [ ] If user not exists: send email anyway (no token) to prevent enumeration
  - [ ] Implement `async def reset_password(token: str, new_password: str) -> None`
  - [ ] Validate token (exists, not expired, not used)
  - [ ] Hash new password
  - [ ] Update user password
  - [ ] Mark token as used
  - [ ] Invalidate all other tokens for user

- [ ] **Task 7: Create Password Reset Endpoints** (AC: 1, 6)
  - [ ] Update `apps/api/src/routes/auth.py`
  - [ ] Define `POST /v1/auth/forgot-password` endpoint
  - [ ] Define `POST /v1/auth/reset-password` endpoint
  - [ ] Handle exceptions and return appropriate error responses
  - [ ] Rate limit forgot-password endpoint (10 requests per hour per IP)

- [ ] **Task 8: Create Custom Exceptions for Password Reset** (AC: 7)
  - [ ] Add to `apps/api/src/exceptions.py`:
  - [ ] `TokenExpiredError` (400 status)
  - [ ] `TokenInvalidError` (400 status)
  - [ ] `TokenAlreadyUsedError` (400 status)
  - [ ] Create exception handlers in error_handler.py
  - [ ] Register handlers in main.py

- [ ] **Task 9: Create Email Template** (AC: 4)
  - [ ] Create `apps/api/src/templates/password_reset_email.html`
  - [ ] Design simple, accessible email template with reset link
  - [ ] Include expiration time (1 hour) in email
  - [ ] Add fallback plain text version
  - [ ] Test email rendering with SendGrid

- [ ] **Task 10: Add Rate Limiting for Forgot Password** (AC: 1)
  - [ ] Reuse rate limiting utility from Story 1.4
  - [ ] Implement 10 requests per hour per IP address limit
  - [ ] Prevent abuse of email sending

- [ ] **Task 11: Write Unit Tests** (AC: 11)
  - [ ] Create `apps/api/tests/unit/test_password_reset_service.py`
  - [ ] Test successful password reset request (user exists)
  - [ ] Test password reset request for non-existent email (no error, no token)
  - [ ] Test token generation and validation
  - [ ] Test expired token rejection
  - [ ] Test invalid token rejection
  - [ ] Test already-used token rejection
  - [ ] Test weak password rejection
  - [ ] Test password update and token invalidation

- [ ] **Task 12: Write Integration Tests** (AC: 12)
  - [ ] Update `apps/api/tests/integration/test_auth_api.py`
  - [ ] Test full password reset flow:
    - [ ] Request password reset
    - [ ] Extract token from database (simulate email)
    - [ ] Reset password with token
    - [ ] Verify old password no longer works
    - [ ] Login with new password successfully
  - [ ] Test expired token returns 400
  - [ ] Test invalid token returns 400
  - [ ] Test reusing same token returns 400
  - [ ] Test forgot-password rate limiting
  - [ ] Test forgot-password with non-existent email doesn't expose user existence

- [ ] **Task 13: Update Documentation** (AC: 1, 6)
  - [ ] Add docstrings to endpoints
  - [ ] Document password reset flow in README
  - [ ] Verify FastAPI auto-docs show both endpoints

## Dev Notes

### Previous Story Context

From **Story 1.1** (relevant learnings):
- Backend structure established
- Environment variable management

From **Story 1.2** (relevant learnings):
- User model with hashed_password field
- UserRepository with get_by_email() and update methods
- Alembic migrations workflow

From **Story 1.3** (relevant learnings):
- Password hashing utilities: `hash_password()`, `verify_password()`
- Password validation in UserCreate schema (8+ chars, letter + number)
- JWT utilities and configuration
- Exception handling framework

From **Story 1.4** (relevant learnings):
- Rate limiting utility with Redis
- Generic error messages to prevent enumeration
- Email case-insensitive lookup

### API Endpoint Specifications

#### Forgot Password Endpoint

**Endpoint:** `POST /v1/auth/forgot-password` [Source: architecture/api-specification.md]

**Request Schema:**
```json
{
  "email": "user@example.com"
}
```

**Success Response (200 OK):**
```json
{
  "message": "If your email is registered, you will receive a password reset link shortly."
}
```

**Note:** Same response whether email exists or not (prevents enumeration)

#### Reset Password Endpoint

**Endpoint:** `POST /v1/auth/reset-password` [Source: architecture/api-specification.md]

**Request Schema:**
```json
{
  "token": "550e8400-e29b-41d4-a716-446655440000",
  "new_password": "NewSecurePass123"
}
```

**Success Response (200 OK):**
```json
{
  "message": "Password reset successful. Please log in with your new password."
}
```

**Error Response (400 Bad Request - Expired Token):**
```json
{
  "error": {
    "code": "TOKEN_EXPIRED",
    "message": "Password reset token has expired. Please request a new one.",
    "details": {},
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

**Error Response (400 Bad Request - Invalid Token):**
```json
{
  "error": {
    "code": "TOKEN_INVALID",
    "message": "Invalid password reset token.",
    "details": {},
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

**Error Response (400 Bad Request - Already Used):**
```json
{
  "error": {
    "code": "TOKEN_ALREADY_USED",
    "message": "This password reset token has already been used.",
    "details": {},
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

### Database Schema Design Decision

**RECOMMENDATION:** Create separate `password_reset_tokens` table (not add to users table)

**Rationale:**
- Multiple outstanding tokens per user (if user requests multiple times)
- Easy cleanup of expired tokens (DELETE WHERE expires_at < NOW())
- Audit trail of reset attempts
- Clear separation of concerns
- No need to add nullable fields to users table

**Schema:**
```sql
CREATE TABLE password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token UUID NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP,  -- NULL if not used yet

    INDEX idx_password_reset_tokens_user_id (user_id),
    INDEX idx_password_reset_tokens_token (token),
    INDEX idx_password_reset_tokens_expires_at (expires_at)
);
```

**SQLAlchemy Model:**
```python
# apps/api/src/models/password_reset_token.py
from sqlalchemy import Column, String, DateTime, ForeignKey, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from datetime import datetime, timedelta
import uuid

from apps.api.src.db.session import Base

class PasswordResetToken(Base):
    __tablename__ = "password_reset_tokens"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    token = Column(UUID(as_uuid=True), unique=True, nullable=False, default=uuid.uuid4)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    used_at = Column(DateTime(timezone=True), nullable=True)

    __table_args__ = (
        Index('idx_password_reset_tokens_user_id', 'user_id'),
        Index('idx_password_reset_tokens_token', 'token'),
        Index('idx_password_reset_tokens_expires_at', 'expires_at'),
    )

    def is_valid(self) -> bool:
        """Check if token is valid (not expired, not used)."""
        return (
            self.used_at is None and
            self.expires_at > datetime.utcnow()
        )
```

### Email Configuration

**Email Service:** SendGrid [Source: architecture/tech-stack.md#Technology Stack Table]

**SendGrid Version:** Latest SDK (9.x)

**Environment Variables:**
```bash
# apps/api/.env.example
# SendGrid Email Configuration
SENDGRID_API_KEY=your-sendgrid-api-key-here
FROM_EMAIL=noreply@learnr.com
FROM_NAME=LearnR Support
FRONTEND_URL=http://localhost:3000  # Dev | https://app.learnr.com (Prod)
```

**Config Settings:**
```python
# apps/api/src/config.py
class Settings(BaseSettings):
    # Existing config...

    # Email Configuration
    SENDGRID_API_KEY: str
    FROM_EMAIL: str = "noreply@learnr.com"
    FROM_NAME: str = "LearnR Support"
    FRONTEND_URL: str  # For password reset links

    class Config:
        env_file = ".env"
```

### Email Service Implementation

```python
# apps/api/src/services/email_service.py
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail, Email, To, Content
from apps.api.src.config import settings
import logging

logger = logging.getLogger(__name__)

class EmailService:
    def __init__(self):
        self.client = SendGridAPIClient(api_key=settings.SENDGRID_API_KEY)
        self.from_email = Email(settings.FROM_EMAIL, settings.FROM_NAME)

    async def send_password_reset_email(self, to_email: str, reset_token: str) -> bool:
        """
        Send password reset email with reset link.

        Args:
            to_email: Recipient email address
            reset_token: UUID reset token

        Returns:
            True if email sent successfully, False otherwise
        """
        try:
            reset_link = f"{settings.FRONTEND_URL}/reset-password?token={reset_token}"

            # HTML email content
            html_content = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <title>Reset Your Password</title>
            </head>
            <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
                <h2 style="color: #2563eb;">Reset Your LearnR Password</h2>
                <p>We received a request to reset your password for your LearnR account.</p>
                <p>Click the button below to reset your password:</p>
                <p style="margin: 30px 0;">
                    <a href="{reset_link}"
                       style="background-color: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
                        Reset Password
                    </a>
                </p>
                <p style="color: #666; font-size: 14px;">
                    This link will expire in <strong>1 hour</strong>.
                </p>
                <p style="color: #666; font-size: 14px;">
                    If you didn't request a password reset, you can safely ignore this email.
                </p>
                <p style="color: #666; font-size: 14px;">
                    If the button doesn't work, copy and paste this link into your browser:<br>
                    <a href="{reset_link}" style="color: #2563eb; word-break: break-all;">{reset_link}</a>
                </p>
                <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                <p style="color: #999; font-size: 12px;">
                    LearnR - CBAP Certification Preparation<br>
                    This is an automated email, please do not reply.
                </p>
            </body>
            </html>
            """

            # Plain text fallback
            text_content = f"""
            Reset Your LearnR Password

            We received a request to reset your password for your LearnR account.

            Click the link below to reset your password:
            {reset_link}

            This link will expire in 1 hour.

            If you didn't request a password reset, you can safely ignore this email.

            ---
            LearnR - CBAP Certification Preparation
            This is an automated email, please do not reply.
            """

            message = Mail(
                from_email=self.from_email,
                to_emails=To(to_email),
                subject="Reset Your LearnR Password",
                plain_text_content=Content("text/plain", text_content),
                html_content=Content("text/html", html_content)
            )

            response = self.client.send(message)

            if response.status_code in [200, 201, 202]:
                logger.info(f"Password reset email sent to {to_email}")
                return True
            else:
                logger.error(f"Failed to send password reset email to {to_email}: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"Error sending password reset email to {to_email}: {str(e)}")
            return False
```

### Password Reset Token Repository

```python
# apps/api/src/repositories/password_reset_repository.py
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime, timedelta
from uuid import UUID
import uuid

from apps.api.src.models.password_reset_token import PasswordResetToken

class PasswordResetRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create_token(self, user_id: UUID, expires_in_hours: int = 1) -> PasswordResetToken:
        """
        Create new password reset token for user.

        Args:
            user_id: User UUID
            expires_in_hours: Token expiration time in hours (default: 1)

        Returns:
            Created PasswordResetToken
        """
        token = PasswordResetToken(
            user_id=user_id,
            token=uuid.uuid4(),
            expires_at=datetime.utcnow() + timedelta(hours=expires_in_hours)
        )

        self.session.add(token)
        await self.session.commit()
        await self.session.refresh(token)

        return token

    async def get_valid_token(self, token: str) -> PasswordResetToken | None:
        """
        Get valid (not expired, not used) password reset token.

        Args:
            token: Token UUID string

        Returns:
            PasswordResetToken if valid, None otherwise
        """
        try:
            token_uuid = UUID(token)
        except ValueError:
            return None

        result = await self.session.execute(
            select(PasswordResetToken).where(
                and_(
                    PasswordResetToken.token == token_uuid,
                    PasswordResetToken.used_at.is_(None),
                    PasswordResetToken.expires_at > datetime.utcnow()
                )
            )
        )

        return result.scalar_one_or_none()

    async def mark_token_used(self, token: str) -> None:
        """
        Mark token as used.

        Args:
            token: Token UUID string
        """
        token_uuid = UUID(token)
        result = await self.session.execute(
            select(PasswordResetToken).where(PasswordResetToken.token == token_uuid)
        )
        token_obj = result.scalar_one_or_none()

        if token_obj:
            token_obj.used_at = datetime.utcnow()
            await self.session.commit()

    async def invalidate_user_tokens(self, user_id: UUID) -> None:
        """
        Mark all user's unused tokens as used (invalidate).

        Args:
            user_id: User UUID
        """
        result = await self.session.execute(
            select(PasswordResetToken).where(
                and_(
                    PasswordResetToken.user_id == user_id,
                    PasswordResetToken.used_at.is_(None)
                )
            )
        )
        tokens = result.scalars().all()

        for token in tokens:
            token.used_at = datetime.utcnow()

        await self.session.commit()
```

### Auth Service Password Reset Methods

```python
# apps/api/src/services/auth_service.py
# Add to existing AuthService from Story 1.3

from apps.api.src.repositories.password_reset_repository import PasswordResetRepository
from apps.api.src.services.email_service import EmailService
from apps.api.src.exceptions import TokenExpiredError, TokenInvalidError, TokenAlreadyUsedError
import logging

logger = logging.getLogger(__name__)

class AuthService:
    def __init__(self, user_repo: UserRepository, reset_token_repo: PasswordResetRepository = None):
        self.user_repo = user_repo
        self.reset_token_repo = reset_token_repo
        self.email_service = EmailService()

    # Existing methods from Story 1.3...

    async def request_password_reset(self, email: str) -> None:
        """
        Request password reset. Always returns success to prevent email enumeration.

        Security: Email sent even if user doesn't exist (but no token created).

        Args:
            email: User email address
        """
        # Look up user
        user = await self.user_repo.get_by_email(email.lower())

        if user:
            # Create reset token
            reset_token = await self.reset_token_repo.create_token(user.id, expires_in_hours=1)

            # Send email
            email_sent = await self.email_service.send_password_reset_email(
                to_email=user.email,
                reset_token=str(reset_token.token)
            )

            if not email_sent:
                logger.error(f"Failed to send password reset email to {user.email}")
        else:
            # User doesn't exist - send email anyway to prevent enumeration
            # But don't create token
            await self.email_service.send_password_reset_email(
                to_email=email,
                reset_token="00000000-0000-0000-0000-000000000000"  # Dummy token, link won't work
            )
            logger.info(f"Password reset requested for non-existent email: {email}")

        # Always return success (no indication of whether user exists)

    async def reset_password(self, token: str, new_password: str) -> None:
        """
        Reset user password with valid token.

        Args:
            token: Password reset token UUID
            new_password: New password (validated by Pydantic)

        Raises:
            TokenInvalidError: If token doesn't exist
            TokenExpiredError: If token is expired
            TokenAlreadyUsedError: If token already used
        """
        # Validate token
        reset_token = await self.reset_token_repo.get_valid_token(token)

        if reset_token is None:
            # Check if token exists but is invalid
            try:
                token_uuid = UUID(token)
                result = await self.reset_token_repo.session.execute(
                    select(PasswordResetToken).where(PasswordResetToken.token == token_uuid)
                )
                existing_token = result.scalar_one_or_none()

                if existing_token:
                    if existing_token.used_at is not None:
                        raise TokenAlreadyUsedError("This password reset token has already been used.")
                    elif existing_token.expires_at < datetime.utcnow():
                        raise TokenExpiredError("Password reset token has expired. Please request a new one.")
            except ValueError:
                pass

            # Token doesn't exist or is invalid
            raise TokenInvalidError("Invalid password reset token.")

        # Get user
        user = await self.user_repo.get_by_id(reset_token.user_id)
        if not user:
            raise TokenInvalidError("Invalid password reset token.")

        # Hash new password
        hashed_password = hash_password(new_password)

        # Update user password
        user.hashed_password = hashed_password
        await self.user_repo.session.commit()

        # Mark token as used
        await self.reset_token_repo.mark_token_used(token)

        # Invalidate all other tokens for this user
        await self.reset_token_repo.invalidate_user_tokens(user.id)

        logger.info(f"Password reset successful for user {user.id}")
```

### Custom Exceptions

```python
# apps/api/src/exceptions.py
# Add to existing exceptions

class TokenExpiredError(AppException):
    """Raised when token has expired (400)."""
    pass

class TokenInvalidError(AppException):
    """Raised when token is invalid (400)."""
    pass

class TokenAlreadyUsedError(AppException):
    """Raised when token has already been used (400)."""
    pass
```

**Exception Handlers:**
```python
# apps/api/src/middleware/error_handler.py
# Add to existing handlers

async def token_expired_error_handler(request: Request, exc: TokenExpiredError):
    """Handle 400 Token Expired errors."""
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={
            "error": {
                "code": "TOKEN_EXPIRED",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

async def token_invalid_error_handler(request: Request, exc: TokenInvalidError):
    """Handle 400 Token Invalid errors."""
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={
            "error": {
                "code": "TOKEN_INVALID",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

async def token_already_used_error_handler(request: Request, exc: TokenAlreadyUsedError):
    """Handle 400 Token Already Used errors."""
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content={
            "error": {
                "code": "TOKEN_ALREADY_USED",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

# Register in main.py:
# app.add_exception_handler(TokenExpiredError, token_expired_error_handler)
# app.add_exception_handler(TokenInvalidError, token_invalid_error_handler)
# app.add_exception_handler(TokenAlreadyUsedError, token_already_used_error_handler)
```

### Pydantic Schemas

```python
# apps/api/src/schemas/auth.py
# Add to existing schemas

from pydantic import validator

class ForgotPasswordRequest(BaseModel):
    """Schema for forgot password request."""
    email: EmailStr

    class Config:
        schema_extra = {
            "example": {
                "email": "user@example.com"
            }
        }

class ForgotPasswordResponse(BaseModel):
    """Schema for forgot password response."""
    message: str

    class Config:
        schema_extra = {
            "example": {
                "message": "If your email is registered, you will receive a password reset link shortly."
            }
        }

class ResetPasswordRequest(BaseModel):
    """Schema for reset password request."""
    token: str
    new_password: str

    @validator('new_password')
    def validate_password(cls, v):
        """Password must be 8+ chars with letter and number (same as registration)."""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        if not any(c.isalpha() for c in v):
            raise ValueError('Password must contain at least one letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one number')
        return v

    class Config:
        schema_extra = {
            "example": {
                "token": "550e8400-e29b-41d4-a716-446655440000",
                "new_password": "NewSecurePass123"
            }
        }

class ResetPasswordResponse(BaseModel):
    """Schema for reset password response."""
    message: str

    class Config:
        schema_extra = {
            "example": {
                "message": "Password reset successful. Please log in with your new password."
            }
        }
```

### Password Reset Endpoints

```python
# apps/api/src/routes/auth.py
# Add to existing routes

from apps.api.src.schemas.auth import (
    ForgotPasswordRequest, ForgotPasswordResponse,
    ResetPasswordRequest, ResetPasswordResponse
)
from apps.api.src.repositories.password_reset_repository import PasswordResetRepository
from apps.api.src.utils.rate_limit import check_rate_limit
from apps.api.src.exceptions import RateLimitError

@router.post(
    "/forgot-password",
    response_model=ForgotPasswordResponse,
    status_code=status.HTTP_200_OK,
    summary="Request password reset",
    description="Request password reset email. Returns success regardless of email existence to prevent enumeration. Rate limited to 10 requests per hour per IP."
)
async def forgot_password(
    request: Request,
    forgot_data: ForgotPasswordRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Request password reset email.

    - **email**: Email address to send reset link

    **Security:** Returns same success message whether email exists or not
    to prevent user enumeration.

    **Rate Limiting:** 10 requests per hour per IP address.
    """
    # Rate limit by IP address (10 requests per hour)
    client_ip = request.client.host
    rate_limit_key = f"rate_limit:forgot_password:{client_ip}"
    is_allowed, retry_after = await check_rate_limit(
        rate_limit_key,
        max_attempts=10,
        window_seconds=3600  # 1 hour
    )

    if not is_allowed:
        raise RateLimitError(
            "Too many password reset requests. Please try again later.",
            retry_after_seconds=retry_after
        )

    # Initialize repositories and service
    user_repo = UserRepository(db)
    reset_token_repo = PasswordResetRepository(db)
    auth_service = AuthService(user_repo, reset_token_repo)

    # Request password reset (always returns success)
    await auth_service.request_password_reset(forgot_data.email)

    return ForgotPasswordResponse(
        message="If your email is registered, you will receive a password reset link shortly."
    )

@router.post(
    "/reset-password",
    response_model=ResetPasswordResponse,
    status_code=status.HTTP_200_OK,
    summary="Reset password with token",
    description="Reset password using valid reset token received via email."
)
async def reset_password(
    reset_data: ResetPasswordRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Reset password with token from email.

    - **token**: Reset token from email link (UUID)
    - **new_password**: New password (min 8 chars, letter + number)

    Returns success message. User must log in with new password (no JWT returned).
    """
    # Initialize repositories and service
    user_repo = UserRepository(db)
    reset_token_repo = PasswordResetRepository(db)
    auth_service = AuthService(user_repo, reset_token_repo)

    # Reset password
    await auth_service.reset_password(reset_data.token, reset_data.new_password)

    return ResetPasswordResponse(
        message="Password reset successful. Please log in with your new password."
    )
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Unit Tests:**

```python
# tests/unit/test_password_reset_service.py
import pytest
from datetime import datetime, timedelta
from apps.api.src.services.auth_service import AuthService
from apps.api.src.exceptions import TokenExpiredError, TokenInvalidError, TokenAlreadyUsedError

@pytest.mark.asyncio
async def test_request_password_reset_existing_user(mock_user_repo, mock_reset_token_repo):
    """Test password reset request for existing user creates token."""
    mock_user = User(id=uuid.uuid4(), email="test@example.com")
    mock_user_repo.get_by_email.return_value = mock_user

    mock_token = PasswordResetToken(
        id=uuid.uuid4(),
        user_id=mock_user.id,
        token=uuid.uuid4(),
        expires_at=datetime.utcnow() + timedelta(hours=1)
    )
    mock_reset_token_repo.create_token.return_value = mock_token

    auth_service = AuthService(mock_user_repo, mock_reset_token_repo)
    await auth_service.request_password_reset("test@example.com")

    # Verify token was created
    mock_reset_token_repo.create_token.assert_called_once()

@pytest.mark.asyncio
async def test_request_password_reset_nonexistent_user(mock_user_repo, mock_reset_token_repo):
    """Test password reset request for non-existent user doesn't create token."""
    mock_user_repo.get_by_email.return_value = None

    auth_service = AuthService(mock_user_repo, mock_reset_token_repo)
    await auth_service.request_password_reset("nonexistent@example.com")

    # Verify NO token was created
    mock_reset_token_repo.create_token.assert_not_called()

@pytest.mark.asyncio
async def test_reset_password_success(mock_user_repo, mock_reset_token_repo):
    """Test successful password reset."""
    mock_user = User(
        id=uuid.uuid4(),
        email="test@example.com",
        hashed_password=hash_password("OldPass123")
    )
    mock_user_repo.get_by_id.return_value = mock_user

    mock_token = PasswordResetToken(
        token=uuid.uuid4(),
        user_id=mock_user.id,
        expires_at=datetime.utcnow() + timedelta(hours=1),
        used_at=None
    )
    mock_reset_token_repo.get_valid_token.return_value = mock_token

    auth_service = AuthService(mock_user_repo, mock_reset_token_repo)
    await auth_service.reset_password(str(mock_token.token), "NewPass456")

    # Verify token marked as used
    mock_reset_token_repo.mark_token_used.assert_called_once()

    # Verify other tokens invalidated
    mock_reset_token_repo.invalidate_user_tokens.assert_called_once()

@pytest.mark.asyncio
async def test_reset_password_expired_token(mock_reset_token_repo):
    """Test password reset with expired token raises error."""
    mock_reset_token_repo.get_valid_token.return_value = None

    auth_service = AuthService(mock_user_repo, mock_reset_token_repo)

    with pytest.raises(TokenExpiredError):
        await auth_service.reset_password("expired-token", "NewPass456")

@pytest.mark.asyncio
async def test_reset_password_invalid_token(mock_reset_token_repo):
    """Test password reset with invalid token raises error."""
    mock_reset_token_repo.get_valid_token.return_value = None

    auth_service = AuthService(mock_user_repo, mock_reset_token_repo)

    with pytest.raises(TokenInvalidError):
        await auth_service.reset_password("invalid-token", "NewPass456")

@pytest.mark.asyncio
async def test_reset_password_weak_password(mock_reset_token_repo):
    """Test password reset with weak password fails validation."""
    # This will be caught by Pydantic validation in the endpoint
    # Test at integration level
    pass
```

**Integration Tests:**

```python
# tests/integration/test_auth_api.py (add to existing)

@pytest.mark.asyncio
async def test_password_reset_full_flow(async_client: AsyncClient, db_session):
    """Test complete password reset flow."""
    # Register user
    register_response = await async_client.post(
        "/v1/auth/register",
        json={"email": "resettest@example.com", "password": "OldPass123"}
    )
    assert register_response.status_code == 201

    # Request password reset
    forgot_response = await async_client.post(
        "/v1/auth/forgot-password",
        json={"email": "resettest@example.com"}
    )
    assert forgot_response.status_code == 200
    assert "If your email is registered" in forgot_response.json()["message"]

    # Get token from database (simulate email)
    from apps.api.src.repositories.password_reset_repository import PasswordResetRepository
    reset_repo = PasswordResetRepository(db_session)
    result = await db_session.execute(
        select(PasswordResetToken)
        .where(PasswordResetToken.user_id == UUID(register_response.json()["user"]["id"]))
        .order_by(PasswordResetToken.created_at.desc())
    )
    reset_token = result.scalar_one()

    # Reset password
    reset_response = await async_client.post(
        "/v1/auth/reset-password",
        json={
            "token": str(reset_token.token),
            "new_password": "NewPass456"
        }
    )
    assert reset_response.status_code == 200
    assert "Password reset successful" in reset_response.json()["message"]

    # Verify old password doesn't work
    old_login = await async_client.post(
        "/v1/auth/login",
        json={"email": "resettest@example.com", "password": "OldPass123"}
    )
    assert old_login.status_code == 401

    # Verify new password works
    new_login = await async_client.post(
        "/v1/auth/login",
        json={"email": "resettest@example.com", "password": "NewPass456"}
    )
    assert new_login.status_code == 200

@pytest.mark.asyncio
async def test_forgot_password_nonexistent_email(async_client: AsyncClient):
    """Test forgot password with non-existent email returns success (no enumeration)."""
    response = await async_client.post(
        "/v1/auth/forgot-password",
        json={"email": "nonexistent@example.com"}
    )

    assert response.status_code == 200
    assert "If your email is registered" in response.json()["message"]

@pytest.mark.asyncio
async def test_reset_password_expired_token(async_client: AsyncClient, db_session):
    """Test reset with expired token returns 400."""
    # Create expired token manually
    from apps.api.src.models.password_reset_token import PasswordResetToken
    expired_token = PasswordResetToken(
        user_id=uuid.uuid4(),
        token=uuid.uuid4(),
        expires_at=datetime.utcnow() - timedelta(hours=2)  # Expired 2 hours ago
    )
    db_session.add(expired_token)
    await db_session.commit()

    response = await async_client.post(
        "/v1/auth/reset-password",
        json={
            "token": str(expired_token.token),
            "new_password": "NewPass456"
        }
    )

    assert response.status_code == 400
    assert response.json()["error"]["code"] == "TOKEN_EXPIRED"

@pytest.mark.asyncio
async def test_reset_password_already_used_token(async_client: AsyncClient, db_session):
    """Test reset with already-used token returns 400."""
    # Register user and request reset
    register_response = await async_client.post(
        "/v1/auth/register",
        json={"email": "usedtoken@example.com", "password": "OldPass123"}
    )

    await async_client.post(
        "/v1/auth/forgot-password",
        json={"email": "usedtoken@example.com"}
    )

    # Get token
    result = await db_session.execute(
        select(PasswordResetToken)
        .where(PasswordResetToken.user_id == UUID(register_response.json()["user"]["id"]))
    )
    reset_token = result.scalar_one()

    # Use token once
    await async_client.post(
        "/v1/auth/reset-password",
        json={
            "token": str(reset_token.token),
            "new_password": "NewPass456"
        }
    )

    # Try to use token again
    response = await async_client.post(
        "/v1/auth/reset-password",
        json={
            "token": str(reset_token.token),
            "new_password": "AnotherPass789"
        }
    )

    assert response.status_code == 400
    assert response.json()["error"]["code"] == "TOKEN_ALREADY_USED"

@pytest.mark.asyncio
async def test_forgot_password_rate_limiting(async_client: AsyncClient):
    """Test forgot password rate limiting."""
    # Make 10 requests (limit)
    for i in range(10):
        response = await async_client.post(
            "/v1/auth/forgot-password",
            json={"email": f"test{i}@example.com"}
        )
        assert response.status_code == 200

    # 11th request should be rate limited
    response = await async_client.post(
        "/v1/auth/forgot-password",
        json={"email": "test11@example.com"}
    )

    assert response.status_code == 429
```

### Coding Standards Reminders

[Source: architecture/coding-standards.md]

- **Async/Await:** All database, Redis, and email operations must use async/await
- **Error Handling:** Use standard error handler middleware
- **Security:** Generic messages to prevent enumeration, secure token generation
- **Email:** Handle SendGrid errors gracefully, log failures

### Dependencies to Add

```txt
# Add to apps/api/requirements.txt
sendgrid==6.11.0
python-decouple==3.8
```

### Success Criteria Checklist

Before marking this story complete, verify:
1. ✓ POST `/v1/auth/forgot-password` endpoint exists
2. ✓ Secure UUID tokens generated with 1-hour expiration
3. ✓ password_reset_tokens table created with indexes
4. ✓ Password reset emails sent with working reset links
5. ✓ Forgot password returns same message for existing and non-existent emails
6. ✓ POST `/v1/auth/reset-password` endpoint exists
7. ✓ Token validation works (expired, invalid, already-used)
8. ✓ Password validation enforced (8+ chars, letter + number)
9. ✓ Password updated and token marked as used
10. ✓ Success message returned (no JWT)
11. ✓ All unit tests pass
12. ✓ Full integration test: forgot → reset → login with new password works
13. ✓ SendGrid configured and emails sending successfully
14. ✓ Rate limiting works for forgot-password endpoint
15. ✓ Email template renders correctly (HTML and plain text)
16. ✓ FastAPI auto-docs show both endpoints

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
