# Story 1.7: Health Check and API Documentation

## Status
Draft

## Story
**As a** developer or DevOps engineer,
**I want** a health check endpoint and auto-generated API documentation,
**so that** I can verify the backend is running and understand available endpoints.

## Acceptance Criteria
1. GET `/health` endpoint returns `200 OK` with JSON `{"status": "healthy", "timestamp": "ISO8601"}`
2. Health check verifies database connectivity (PostgreSQL ping)
3. FastAPI auto-generated OpenAPI documentation available at `/docs` (Swagger UI)
4. `/docs` shows all implemented endpoints with request/response schemas
5. `/redoc` alternative documentation format available
6. Health check does not require authentication (publicly accessible for monitoring)
7. API documentation shows authentication requirements (lock icon) for protected endpoints
8. Response examples included in API docs for each endpoint
9. Health check returns 503 Service Unavailable if database connection fails
10. README documents how to access API docs and health check endpoint

## Tasks / Subtasks

- [ ] **Task 1: Create Health Check Endpoint** (AC: 1, 2, 6, 9)
  - [ ] Create `apps/api/src/routes/health.py`
  - [ ] Define `GET /health` endpoint (no authentication required)
  - [ ] Return status "healthy" and ISO 8601 timestamp
  - [ ] Check database connectivity by executing simple query
  - [ ] Return 200 OK if database is accessible
  - [ ] Return 503 Service Unavailable if database connection fails
  - [ ] Include database status in response
  - [ ] Register health router in main.py

- [ ] **Task 2: Configure OpenAPI Metadata** (AC: 3, 4, 5, 7)
  - [ ] Update FastAPI app initialization in `apps/api/src/main.py`
  - [ ] Configure OpenAPI metadata: title, description, version, contact, license
  - [ ] Configure security scheme for JWT Bearer authentication
  - [ ] Verify `/docs` (Swagger UI) is accessible
  - [ ] Verify `/redoc` (ReDoc) is accessible
  - [ ] Ensure protected endpoints show lock icon in documentation

- [ ] **Task 3: Add Response Examples to Schemas** (AC: 8)
  - [ ] Review all Pydantic schemas created in Stories 1.3-1.6
  - [ ] Add `schema_extra` examples to schemas:
    - [ ] UserCreate, UserResponse, UserUpdate
    - [ ] RegisterResponse, LoginRequest, LoginResponse
    - [ ] ForgotPasswordRequest, ResetPasswordRequest
  - [ ] Verify examples appear in `/docs`

- [ ] **Task 4: Add Endpoint Descriptions** (AC: 4, 8)
  - [ ] Review all route handlers in auth.py, users.py
  - [ ] Ensure comprehensive docstrings with:
    - [ ] Summary
    - [ ] Description
    - [ ] Parameter descriptions
    - [ ] Response descriptions
  - [ ] Add example responses in endpoint decorators
  - [ ] Verify descriptions appear in `/docs`

- [ ] **Task 5: Create Health Check Response Schema** (AC: 1, 9)
  - [ ] Create `apps/api/src/schemas/health.py`
  - [ ] Define `HealthResponse` schema with status, timestamp, database fields
  - [ ] Add examples for healthy and unhealthy states

- [ ] **Task 6: Write Health Check Tests** (AC: 2, 9)
  - [ ] Create `apps/api/tests/integration/test_health.py`
  - [ ] Test health endpoint returns 200 with healthy status
  - [ ] Test health endpoint includes timestamp in ISO 8601 format
  - [ ] Test health endpoint includes database status
  - [ ] Test health endpoint accessible without authentication
  - [ ] Test health endpoint returns 503 when database unavailable (mock database failure)

- [ ] **Task 7: Update README Documentation** (AC: 10)
  - [ ] Update `apps/api/README.md` with API documentation section
  - [ ] Document how to access Swagger UI at `/docs`
  - [ ] Document how to access ReDoc at `/redoc`
  - [ ] Document health check endpoint at `/health`
  - [ ] Include example responses
  - [ ] Add links to deployed documentation (production/staging)

- [ ] **Task 8: Verify OpenAPI Specification** (AC: 4)
  - [ ] Access `/openapi.json` endpoint to view raw OpenAPI spec
  - [ ] Verify all endpoints from Stories 1.3-1.6 are documented
  - [ ] Verify request/response schemas are complete
  - [ ] Verify security requirements are properly marked

- [ ] **Task 9: Test API Documentation UI** (AC: 3, 5, 7)
  - [ ] Test Swagger UI at `/docs` renders correctly
  - [ ] Test ReDoc at `/redoc` renders correctly
  - [ ] Verify all endpoints are listed
  - [ ] Verify authentication lock icon appears on protected endpoints
  - [ ] Test "Try it out" functionality in Swagger UI
  - [ ] Test authentication in Swagger UI (enter JWT token)

## Dev Notes

### Previous Story Context

From **Story 1.1** (relevant learnings):
- FastAPI application structure
- README documentation patterns

From **Story 1.2** (relevant learnings):
- Database session management
- PostgreSQL connection configuration

From **Story 1.3-1.6** (relevant learnings):
- All authentication endpoints: register, login, forgot-password, reset-password
- User profile endpoints: GET/PUT /users/me
- Pydantic schemas with examples
- JWT authentication dependency

### Health Check Endpoint

**Endpoint:** `GET /health` [Source: Epic 1.7 AC]

**Authentication:** None (publicly accessible)

**Success Response (200 OK):**
```json
{
  "status": "healthy",
  "timestamp": "2025-11-21T10:30:00.123456Z",
  "database": {
    "status": "connected",
    "response_time_ms": 5
  }
}
```

**Failure Response (503 Service Unavailable):**
```json
{
  "status": "unhealthy",
  "timestamp": "2025-11-21T10:30:00.123456Z",
  "database": {
    "status": "disconnected",
    "error": "Connection timeout"
  }
}
```

**Implementation:**

```python
# apps/api/src/schemas/health.py
from pydantic import BaseModel
from datetime import datetime

class DatabaseHealth(BaseModel):
    """Database health status."""
    status: str  # "connected" or "disconnected"
    response_time_ms: int | None = None
    error: str | None = None

    class Config:
        schema_extra = {
            "example": {
                "status": "connected",
                "response_time_ms": 5
            }
        }

class HealthResponse(BaseModel):
    """Health check response."""
    status: str  # "healthy" or "unhealthy"
    timestamp: str  # ISO 8601 format
    database: DatabaseHealth

    class Config:
        schema_extra = {
            "example": {
                "status": "healthy",
                "timestamp": "2025-11-21T10:30:00.123456Z",
                "database": {
                    "status": "connected",
                    "response_time_ms": 5
                }
            }
        }
```

```python
# apps/api/src/routes/health.py
from fastapi import APIRouter, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from datetime import datetime
import time

from apps.api.src.db.session import get_db
from apps.api.src.schemas.health import HealthResponse, DatabaseHealth

router = APIRouter(tags=["health"])

@router.get(
    "/health",
    response_model=HealthResponse,
    status_code=status.HTTP_200_OK,
    summary="Health check endpoint",
    description="Check API and database health status. Does not require authentication.",
    responses={
        200: {
            "description": "API is healthy",
            "content": {
                "application/json": {
                    "example": {
                        "status": "healthy",
                        "timestamp": "2025-11-21T10:30:00.123456Z",
                        "database": {
                            "status": "connected",
                            "response_time_ms": 5
                        }
                    }
                }
            }
        },
        503: {
            "description": "API is unhealthy (database connection failed)",
            "content": {
                "application/json": {
                    "example": {
                        "status": "unhealthy",
                        "timestamp": "2025-11-21T10:30:00.123456Z",
                        "database": {
                            "status": "disconnected",
                            "error": "Connection timeout"
                        }
                    }
                }
            }
        }
    }
)
async def health_check(db: AsyncSession = Depends(get_db)):
    """
    Health check endpoint for monitoring and load balancers.

    Verifies:
    - API is running
    - Database connection is healthy

    **No authentication required** - publicly accessible for monitoring tools.

    Returns 200 if healthy, 503 if database connection fails.
    """
    timestamp = datetime.utcnow().isoformat() + "Z"

    # Check database connectivity
    try:
        start_time = time.time()
        await db.execute(text("SELECT 1"))
        response_time_ms = int((time.time() - start_time) * 1000)

        return HealthResponse(
            status="healthy",
            timestamp=timestamp,
            database=DatabaseHealth(
                status="connected",
                response_time_ms=response_time_ms
            )
        )
    except Exception as e:
        # Database connection failed
        from fastapi import Response
        response = Response(
            content=HealthResponse(
                status="unhealthy",
                timestamp=timestamp,
                database=DatabaseHealth(
                    status="disconnected",
                    error=str(e)
                )
            ).json(),
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            media_type="application/json"
        )
        return response
```

**Register health router:**
```python
# apps/api/src/main.py
from apps.api.src.routes import health

# Register health router (no /v1 prefix - root level)
app.include_router(health.router)
```

### OpenAPI Configuration

**FastAPI OpenAPI Metadata:** [Source: architecture/api-specification.md]

```python
# apps/api/src/main.py
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI(
    title="LearnR API",
    description="""
    # LearnR API - CBAP Certification Preparation Platform

    The LearnR API provides endpoints for user authentication, adaptive quiz sessions,
    competency tracking, and personalized reading recommendations for CBAP exam preparation.

    ## Features

    - **User Authentication**: Registration, login, password reset with JWT tokens
    - **User Profile Management**: Update exam date, target score, study preferences
    - **Adaptive Quiz Engine**: IRT-based question selection (future)
    - **Competency Tracking**: Real-time competency scores per knowledge area (future)
    - **Reading Library**: Personalized BABOK content recommendations (future)
    - **Spaced Repetition**: SM-2 algorithm for optimal review scheduling (future)

    ## Authentication

    Most endpoints require JWT authentication. Include the token in the Authorization header:

    ```
    Authorization: Bearer <your_jwt_token>
    ```

    Get a token by calling `/v1/auth/register` or `/v1/auth/login`.

    ## Base URL

    - **Development**: http://localhost:8000
    - **Production**: https://api.learnr.com

    ## Support

    For API support, contact: support@learnr.com
    """,
    version="1.0.0",
    contact={
        "name": "LearnR Support",
        "email": "support@learnr.com",
        "url": "https://learnr.com"
    },
    license_info={
        "name": "Proprietary",
        "url": "https://learnr.com/terms"
    },
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# Configure JWT Bearer authentication for OpenAPI
from fastapi.security import HTTPBearer

security = HTTPBearer()

def custom_openapi():
    """Customize OpenAPI schema with security scheme."""
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        description=app.description,
        routes=app.routes,
    )

    # Add JWT Bearer security scheme
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
            "description": "Enter your JWT token from /v1/auth/login or /v1/auth/register"
        }
    }

    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi
```

### Adding Security to Protected Endpoints

For endpoints that require authentication, FastAPI automatically marks them as protected when using the `Depends(get_current_user)` dependency. The OpenAPI schema will show a lock icon.

**Example (already implemented in Story 1.6):**
```python
# apps/api/src/routes/users.py
from fastapi.security import HTTPBearer

security = HTTPBearer()

@router.get("/me", response_model=UserResponse)
async def get_user_profile(
    current_user: User = Depends(get_current_user),
    token: str = Depends(security)  # This adds the lock icon
):
    return UserResponse.from_orm(current_user)
```

**Alternative approach (using OpenAPI security parameter):**
```python
@router.get(
    "/me",
    response_model=UserResponse,
    summary="Get current user profile",
    dependencies=[Depends(get_current_user)],
    responses={
        200: {"description": "User profile retrieved successfully"},
        401: {"description": "Authentication required"}
    }
)
async def get_user_profile(current_user: User = Depends(get_current_user)):
    """Get authenticated user's profile."""
    return UserResponse.from_orm(current_user)
```

### Enhancing Schema Examples

All Pydantic schemas should include comprehensive examples in `schema_extra`:

```python
# apps/api/src/schemas/user.py
class UserCreate(BaseModel):
    """Schema for user registration."""
    email: EmailStr
    password: str

    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        if not any(c.isalpha() for c in v):
            raise ValueError('Password must contain at least one letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one number')
        return v

    class Config:
        schema_extra = {
            "example": {
                "email": "user@example.com",
                "password": "SecurePass123"
            }
        }
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Integration Tests:**

```python
# tests/integration/test_health.py
import pytest
from httpx import AsyncClient
from sqlalchemy import text
from datetime import datetime

@pytest.mark.asyncio
async def test_health_check_healthy(async_client: AsyncClient):
    """Test health check returns 200 when database is healthy."""
    response = await async_client.get("/health")

    assert response.status_code == 200
    data = response.json()

    assert data["status"] == "healthy"
    assert "timestamp" in data
    assert data["database"]["status"] == "connected"
    assert isinstance(data["database"]["response_time_ms"], int)

@pytest.mark.asyncio
async def test_health_check_timestamp_format(async_client: AsyncClient):
    """Test health check timestamp is in ISO 8601 format."""
    response = await async_client.get("/health")

    assert response.status_code == 200
    timestamp = response.json()["timestamp"]

    # Verify ISO 8601 format
    datetime.fromisoformat(timestamp.replace("Z", "+00:00"))

@pytest.mark.asyncio
async def test_health_check_includes_database_status(async_client: AsyncClient):
    """Test health check includes database connectivity status."""
    response = await async_client.get("/health")

    assert response.status_code == 200
    data = response.json()

    assert "database" in data
    assert "status" in data["database"]
    assert data["database"]["status"] in ["connected", "disconnected"]

@pytest.mark.asyncio
async def test_health_check_no_authentication_required(async_client: AsyncClient):
    """Test health check is accessible without authentication."""
    # No Authorization header
    response = await async_client.get("/health")

    assert response.status_code == 200

@pytest.mark.asyncio
async def test_health_check_database_failure(async_client: AsyncClient, db_session):
    """Test health check returns 503 when database is unavailable."""
    # Mock database failure by closing connection
    await db_session.close()

    response = await async_client.get("/health")

    assert response.status_code == 503
    data = response.json()

    assert data["status"] == "unhealthy"
    assert data["database"]["status"] == "disconnected"
    assert "error" in data["database"]
```

**Documentation Verification Tests:**

```python
# tests/integration/test_api_docs.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_swagger_ui_accessible(async_client: AsyncClient):
    """Test Swagger UI is accessible at /docs."""
    response = await async_client.get("/docs")

    assert response.status_code == 200
    assert "text/html" in response.headers["content-type"]
    assert b"swagger-ui" in response.content

@pytest.mark.asyncio
async def test_redoc_accessible(async_client: AsyncClient):
    """Test ReDoc is accessible at /redoc."""
    response = await async_client.get("/redoc")

    assert response.status_code == 200
    assert "text/html" in response.headers["content-type"]
    assert b"redoc" in response.content

@pytest.mark.asyncio
async def test_openapi_json_accessible(async_client: AsyncClient):
    """Test OpenAPI JSON spec is accessible."""
    response = await async_client.get("/openapi.json")

    assert response.status_code == 200
    assert "application/json" in response.headers["content-type"]

    spec = response.json()
    assert "openapi" in spec
    assert "info" in spec
    assert "paths" in spec

@pytest.mark.asyncio
async def test_openapi_spec_includes_all_endpoints(async_client: AsyncClient):
    """Test OpenAPI spec includes all implemented endpoints."""
    response = await async_client.get("/openapi.json")
    spec = response.json()

    # Check authentication endpoints
    assert "/v1/auth/register" in spec["paths"]
    assert "/v1/auth/login" in spec["paths"]
    assert "/v1/auth/forgot-password" in spec["paths"]
    assert "/v1/auth/reset-password" in spec["paths"]

    # Check user endpoints
    assert "/v1/users/me" in spec["paths"]

    # Check health endpoint
    assert "/health" in spec["paths"]

@pytest.mark.asyncio
async def test_openapi_spec_includes_security_scheme(async_client: AsyncClient):
    """Test OpenAPI spec includes JWT Bearer security scheme."""
    response = await async_client.get("/openapi.json")
    spec = response.json()

    assert "components" in spec
    assert "securitySchemes" in spec["components"]
    assert "BearerAuth" in spec["components"]["securitySchemes"]

    bearer_auth = spec["components"]["securitySchemes"]["BearerAuth"]
    assert bearer_auth["type"] == "http"
    assert bearer_auth["scheme"] == "bearer"
    assert bearer_auth["bearerFormat"] == "JWT"

@pytest.mark.asyncio
async def test_protected_endpoints_marked_with_security(async_client: AsyncClient):
    """Test protected endpoints show security requirements in OpenAPI spec."""
    response = await async_client.get("/openapi.json")
    spec = response.json()

    # Check GET /v1/users/me requires authentication
    users_me_endpoint = spec["paths"]["/v1/users/me"]["get"]

    # Protected endpoints should have security requirement
    # (This depends on how you configure security in FastAPI)
    # Verify it's marked as protected
    assert "responses" in users_me_endpoint
    assert "401" in users_me_endpoint["responses"]
```

### README Documentation Update

Add to `apps/api/README.md`:

```markdown
# LearnR API

CBAP Certification Preparation Platform Backend API

## API Documentation

### Interactive Documentation

Once the API is running, access interactive API documentation:

- **Swagger UI**: http://localhost:8000/docs
  - Interactive API explorer with "Try it out" functionality
  - Test endpoints directly from the browser
  - View request/response schemas and examples

- **ReDoc**: http://localhost:8000/redoc
  - Alternative documentation format
  - Clean, responsive design
  - Better for reading and reference

- **OpenAPI Spec**: http://localhost:8000/openapi.json
  - Raw OpenAPI 3.0 specification
  - Use with API clients like Postman or Insomnia

### Using Authentication in Swagger UI

1. Register or login to get a JWT token:
   - POST `/v1/auth/register` or POST `/v1/auth/login`
   - Copy the `token` from the response

2. Click the "Authorize" button (lock icon) in Swagger UI

3. Enter your token in the format: `Bearer <your_token>`
   - Example: `Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`

4. Click "Authorize" - protected endpoints are now accessible

### Health Check

Monitor API health:

```bash
curl http://localhost:8000/health
```

Response (healthy):
```json
{
  "status": "healthy",
  "timestamp": "2025-11-21T10:30:00.123456Z",
  "database": {
    "status": "connected",
    "response_time_ms": 5
  }
}
```

Use this endpoint for:
- Load balancer health checks
- Container orchestration (Docker, Kubernetes)
- Monitoring tools (Prometheus, Datadog)
- CI/CD health verification

## Endpoints Summary

### Authentication (`/v1/auth`)
- `POST /v1/auth/register` - Register new user
- `POST /v1/auth/login` - User login
- `POST /v1/auth/forgot-password` - Request password reset
- `POST /v1/auth/reset-password` - Reset password with token

### Users (`/v1/users`)
- `GET /v1/users/me` - Get current user profile (protected)
- `PUT /v1/users/me` - Update user profile (protected)

### Health
- `GET /health` - API health check (public)

## Deployed Documentation

- **Production API Docs**: https://api.learnr.com/docs
- **Staging API Docs**: https://api-staging.learnr.com/docs
```

### Coding Standards Reminders

[Source: architecture/coding-standards.md]

- **Documentation:** Add comprehensive docstrings to all endpoints
- **Examples:** Include schema_extra examples in all Pydantic models
- **Error Handling:** Document error responses in OpenAPI

### Success Criteria Checklist

Before marking this story complete, verify:
1. ✓ GET `/health` endpoint returns 200 with status and timestamp
2. ✓ Health check verifies database connectivity with response time
3. ✓ Swagger UI accessible at `/docs` with all endpoints
4. ✓ All implemented endpoints from Stories 1.3-1.6 appear in `/docs`
5. ✓ ReDoc accessible at `/redoc`
6. ✓ Health check accessible without authentication
7. ✓ Protected endpoints show lock icon in Swagger UI
8. ✓ All schemas have examples in API documentation
9. ✓ Health check returns 503 when database connection fails
10. ✓ README documents how to access API docs and health check
11. ✓ OpenAPI JSON spec accessible at `/openapi.json`
12. ✓ "Try it out" functionality works in Swagger UI
13. ✓ Authentication works in Swagger UI (Bearer token)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
