# Story 1.4: User Login API

## Status
Draft

## Story
**As a** registered user,
**I want** to log in with my email and password,
**so that** I can access my personalized learning dashboard and progress.

## Acceptance Criteria
1. POST `/api/auth/login` endpoint accepts `email` and `password` in request body
2. User lookup by email (case-insensitive)
3. Password verification using bcrypt/Argon2 compare function
4. On successful authentication: Return JWT token (7-day expiration) and user object
5. On failed authentication: Return 401 Unauthorized with generic message "Invalid email or password" (no distinction to prevent enumeration)
6. JWT token structure same as registration (user_id in payload)
7. Rate limiting: Maximum 5 login attempts per email per 15 minutes (prevent brute force)
8. Unit tests: Valid login, invalid password, non-existent email, rate limiting
9. Integration test: Login returns valid JWT that can be used for authenticated endpoints
10. Security: No sensitive information in error messages, timing-safe password comparison

## Tasks / Subtasks

- [ ] **Task 1: Install Redis and Configure Connection** (AC: 7)
  - [ ] Add to `requirements.txt`: `redis==5.0.x`, `redis-py==5.0.x`
  - [ ] Add Redis configuration to `apps/api/src/config.py`: REDIS_URL, REDIS_HOST, REDIS_PORT
  - [ ] Create `apps/api/src/db/redis_client.py` with async Redis connection
  - [ ] Add REDIS_URL to `.env.example`
  - [ ] Test Redis connection on application startup
  - [ ] Add Redis service to `docker-compose.yml` for local development

- [ ] **Task 2: Create Rate Limiting Utility** (AC: 7)
  - [ ] Create `apps/api/src/utils/rate_limit.py`
  - [ ] Implement `async def check_rate_limit(key: str, max_attempts: int, window_seconds: int) -> bool`
  - [ ] Use Redis INCR and EXPIRE commands for sliding window rate limiting
  - [ ] Return True if under limit, False if exceeded
  - [ ] Implement `async def get_remaining_attempts(key: str, max_attempts: int) -> int`

- [ ] **Task 3: Create Rate Limit Exception** (AC: 7)
  - [ ] Add `RateLimitError` to `apps/api/src/exceptions.py` (429 status)
  - [ ] Create exception handler in `apps/api/src/middleware/error_handler.py`
  - [ ] Return error with "retry_after_seconds" in details
  - [ ] Register exception handler in `main.py`

- [ ] **Task 4: Create Login Request/Response Schemas** (AC: 1, 4)
  - [ ] Update `apps/api/src/schemas/auth.py`
  - [ ] Define `LoginRequest` schema with email and password fields
  - [ ] Define `LoginResponse` schema (same as RegisterResponse: user + token)
  - [ ] Add schema examples for API documentation

- [ ] **Task 5: Add Login Method to Auth Service** (AC: 2, 3, 4, 5, 6, 10)
  - [ ] Update `apps/api/src/services/auth_service.py`
  - [ ] Implement `async def login_user(email: str, password: str) -> tuple[User, str]`
  - [ ] Look up user by email (case-insensitive) using user_repository
  - [ ] If user not found: raise AuthenticationError with generic message
  - [ ] Verify password using `verify_password()` from utils
  - [ ] If password invalid: raise AuthenticationError with generic message
  - [ ] Generate JWT token (same as registration, 7-day expiration)
  - [ ] Return (user, token) tuple
  - [ ] Ensure timing-safe comparison (bcrypt.verify is already timing-safe)

- [ ] **Task 6: Create Authentication Exception** (AC: 5)
  - [ ] Add `AuthenticationError` to `apps/api/src/exceptions.py` (401 status)
  - [ ] Create exception handler returning generic error message
  - [ ] Ensure no information leakage (same message for wrong email or wrong password)
  - [ ] Register exception handler in `main.py`

- [ ] **Task 7: Create Login Endpoint** (AC: 1, 2, 3, 4, 5, 6, 7)
  - [ ] Update `apps/api/src/routes/auth.py`
  - [ ] Define `POST /v1/auth/login` endpoint
  - [ ] Check rate limit before attempting login (5 attempts per 15 minutes per email)
  - [ ] Accept `LoginRequest` schema in request body
  - [ ] Call `auth_service.login_user()`
  - [ ] Return `LoginResponse` with user object and JWT token
  - [ ] Handle AuthenticationError and return 401 with generic message
  - [ ] Handle RateLimitError and return 429 with retry_after

- [ ] **Task 8: Add Docker Compose Redis Service** (AC: 7)
  - [ ] Update `infrastructure/docker/docker-compose.yml`
  - [ ] Add Redis 7.2.x service with persistent volume
  - [ ] Configure Redis port (6379) and password (optional for dev)
  - [ ] Document Redis startup in README

- [ ] **Task 9: Write Unit Tests** (AC: 8)
  - [ ] Create `apps/api/tests/unit/test_rate_limit.py`
  - [ ] Test rate limit allows requests under threshold
  - [ ] Test rate limit blocks requests over threshold
  - [ ] Test rate limit window expiration resets counter
  - [ ] Update `apps/api/tests/unit/test_auth_service.py`
  - [ ] Test successful login with valid credentials
  - [ ] Test login failure with invalid password (mock repository)
  - [ ] Test login failure with non-existent email (mock repository)
  - [ ] Test generic error message for both cases

- [ ] **Task 10: Write Integration Tests** (AC: 9, 10)
  - [ ] Update `apps/api/tests/integration/test_auth_api.py`
  - [ ] Test successful login returns user and token
  - [ ] Test login with wrong password returns 401 with generic message
  - [ ] Test login with non-existent email returns 401 with generic message
  - [ ] Test error messages are identical for wrong email vs wrong password
  - [ ] Test rate limiting: 6th attempt within 15 minutes returns 429
  - [ ] Test JWT token from login can be used for authenticated endpoints (Story 1.6 dependency - add placeholder)
  - [ ] Test case-insensitive email lookup (login with different case)
  - [ ] Verify response times are similar for wrong email vs wrong password (timing attack prevention)

- [ ] **Task 11: Update API Documentation** (AC: 1)
  - [ ] Add docstrings to login endpoint
  - [ ] Document rate limiting behavior in endpoint description
  - [ ] Verify FastAPI auto-docs show login endpoint at `/docs`

## Dev Notes

### Previous Story Context

From **Story 1.1** (relevant learnings):
- Backend structure: `apps/api/src/` with established patterns
- Docker Compose for local infrastructure

From **Story 1.2** (relevant learnings):
- User model with email and hashed_password fields
- Database session management
- UserRepository with `get_by_email()` method

From **Story 1.3** (relevant learnings):
- Auth utilities: `hash_password()`, `verify_password()`, `create_access_token()` already implemented
- AuthService pattern established
- UserRepository with `get_by_email()` method
- JWT configuration: 7-day expiration, HS256 algorithm
- Exception handling framework with global handlers
- RegisterResponse schema (reuse as LoginResponse)

### API Endpoint Specification

**Endpoint:** `POST /v1/auth/login` [Source: architecture/api-specification.md]

**Request Schema:**
```json
{
  "email": "user@example.com",
  "password": "SecurePass123"
}
```

**Success Response (200 OK):**
```json
{
  "user": {
    "id": "uuid-here",
    "email": "user@example.com",
    "created_at": "2025-11-21T10:30:00Z",
    "exam_date": null,
    "target_score": null,
    "daily_study_time": null,
    "knowledge_level": null,
    "motivation": null,
    "referral_source": null,
    "is_admin": false,
    "dark_mode": "auto"
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**Error Response (401 Unauthorized):**
```json
{
  "error": {
    "code": "AUTHENTICATION_ERROR",
    "message": "Invalid email or password",
    "details": {},
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

**Error Response (429 Rate Limit Exceeded):**
```json
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many login attempts. Please try again later.",
    "details": {
      "retry_after_seconds": 900
    },
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

### Redis Configuration

**Redis Version:** 7.2.x [Source: architecture/tech-stack.md#Technology Stack Table]

**Purpose:** Rate limiting, session caching, JWT blacklist (future) [Source: architecture/tech-stack.md]

**Connection Configuration:**
```python
# apps/api/src/config.py
class Settings(BaseSettings):
    # Existing JWT config...

    # Redis Configuration
    REDIS_URL: str = "redis://localhost:6379/0"
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_PASSWORD: str = None  # Optional for development
    REDIS_DB: int = 0

    class Config:
        env_file = ".env"
```

**Environment Variables:**
```bash
# apps/api/.env.example
# Redis (for rate limiting and caching)
REDIS_URL=redis://localhost:6379/0
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=  # Leave empty for dev, set in production
REDIS_DB=0
```

**Async Redis Client:**
```python
# apps/api/src/db/redis_client.py
from redis.asyncio import Redis
from apps.api.src.config import settings

redis_client: Redis = None

async def get_redis() -> Redis:
    """Get Redis client instance."""
    global redis_client
    if redis_client is None:
        redis_client = Redis.from_url(
            settings.REDIS_URL,
            encoding="utf-8",
            decode_responses=True,
            socket_connect_timeout=5,
            socket_timeout=5,
        )
    return redis_client

async def close_redis():
    """Close Redis connection."""
    global redis_client
    if redis_client:
        await redis_client.close()
        redis_client = None

# Register lifecycle hooks in main.py:
# @app.on_event("startup")
# async def startup():
#     await get_redis()
#
# @app.on_event("shutdown")
# async def shutdown():
#     await close_redis()
```

### Rate Limiting Implementation

**Rate Limit:** 5 login attempts per 15 minutes per email [Source: Epic 1.4 AC #7]

**Redis Key Pattern:** `rate_limit:login:{email}`

**Sliding Window Implementation:**
```python
# apps/api/src/utils/rate_limit.py
from redis.asyncio import Redis
from apps.api.src.db.redis_client import get_redis

async def check_rate_limit(
    key: str,
    max_attempts: int,
    window_seconds: int
) -> tuple[bool, int]:
    """
    Check if rate limit is exceeded.

    Args:
        key: Redis key for rate limiting (e.g., "rate_limit:login:user@example.com")
        max_attempts: Maximum attempts allowed
        window_seconds: Time window in seconds

    Returns:
        Tuple of (is_allowed: bool, retry_after_seconds: int)
    """
    redis = await get_redis()

    # Increment counter
    current = await redis.incr(key)

    # Set expiration on first request
    if current == 1:
        await redis.expire(key, window_seconds)

    # Check if over limit
    if current > max_attempts:
        # Get TTL for retry_after
        ttl = await redis.ttl(key)
        return False, ttl if ttl > 0 else window_seconds

    return True, 0

async def reset_rate_limit(key: str):
    """Reset rate limit counter (e.g., after successful login)."""
    redis = await get_redis()
    await redis.delete(key)

async def get_remaining_attempts(key: str, max_attempts: int) -> int:
    """Get remaining attempts before rate limit."""
    redis = await get_redis()
    current = await redis.get(key)
    if current is None:
        return max_attempts
    return max(0, max_attempts - int(current))
```

### Security Considerations

**Timing Attack Prevention:** [Source: Epic 1.4 AC #10]

The `verify_password()` function from passlib/bcrypt is already timing-safe. However, ensure the overall login flow doesn't leak information through timing:

```python
# apps/api/src/services/auth_service.py
import asyncio

async def login_user(self, email: str, password: str) -> tuple[User, str]:
    """
    Authenticate user with email and password.

    Security: Uses timing-safe password comparison and generic error messages
    to prevent user enumeration attacks.

    Args:
        email: User email (case-insensitive)
        password: Plain text password

    Returns:
        Tuple of (User model, JWT token)

    Raises:
        AuthenticationError: If authentication fails (generic message)
    """
    # Look up user (case-insensitive)
    user = await self.user_repo.get_by_email(email.lower())

    # Timing-safe authentication check
    # Always verify password even if user not found to prevent timing attacks
    if user is None:
        # Perform dummy hash verification to maintain constant timing
        verify_password("dummy_password", "$2b$12$dummy_hash_to_maintain_timing_consistency_for_security_purposes")
        raise AuthenticationError("Invalid email or password")

    # Verify password (bcrypt.verify is timing-safe)
    if not verify_password(password, user.hashed_password):
        raise AuthenticationError("Invalid email or password")

    # Generate JWT token (same as registration)
    access_token = create_access_token(
        data={"sub": str(user.id)},
        expires_delta=timedelta(days=settings.JWT_ACCESS_TOKEN_EXPIRE_DAYS)
    )

    return user, access_token
```

**Generic Error Messages:** [Source: Epic 1.4 AC #5]

Always return "Invalid email or password" regardless of whether:
- Email doesn't exist
- Password is incorrect
- Account is locked/disabled (future)

This prevents attackers from enumerating valid email addresses.

### Exception Classes

```python
# apps/api/src/exceptions.py
# Add to existing exceptions from Story 1.3

class AuthenticationError(AppException):
    """Raised when authentication fails (401)."""
    pass

class RateLimitError(AppException):
    """Raised when rate limit is exceeded (429)."""
    def __init__(self, message: str, retry_after_seconds: int):
        super().__init__(message, {"retry_after_seconds": retry_after_seconds})
        self.retry_after_seconds = retry_after_seconds
```

**Exception Handlers:**
```python
# apps/api/src/middleware/error_handler.py
# Add to existing handlers from Story 1.3

async def authentication_error_handler(request: Request, exc: AuthenticationError):
    """Handle 401 Unauthorized errors."""
    return JSONResponse(
        status_code=status.HTTP_401_UNAUTHORIZED,
        content={
            "error": {
                "code": "AUTHENTICATION_ERROR",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        }
    )

async def rate_limit_error_handler(request: Request, exc: RateLimitError):
    """Handle 429 Rate Limit Exceeded errors."""
    return JSONResponse(
        status_code=status.HTTP_429_TOO_MANY_REQUESTS,
        content={
            "error": {
                "code": "RATE_LIMIT_EXCEEDED",
                "message": exc.message,
                "details": exc.details,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "request_id": str(uuid.uuid4())
            }
        },
        headers={
            "Retry-After": str(exc.retry_after_seconds)
        }
    )

# Register in main.py:
# app.add_exception_handler(AuthenticationError, authentication_error_handler)
# app.add_exception_handler(RateLimitError, rate_limit_error_handler)
```

### Pydantic Schemas

```python
# apps/api/src/schemas/auth.py
# Add to existing schemas from Story 1.3

class LoginRequest(BaseModel):
    """Schema for user login."""
    email: EmailStr
    password: str

    class Config:
        schema_extra = {
            "example": {
                "email": "user@example.com",
                "password": "SecurePass123"
            }
        }

# Reuse RegisterResponse as LoginResponse (same structure)
LoginResponse = RegisterResponse
```

### Login Endpoint Implementation

```python
# apps/api/src/routes/auth.py
# Add to existing routes from Story 1.3

from apps.api.src.schemas.auth import LoginRequest, LoginResponse
from apps.api.src.utils.rate_limit import check_rate_limit, reset_rate_limit
from apps.api.src.exceptions import RateLimitError

@router.post(
    "/login",
    response_model=LoginResponse,
    status_code=status.HTTP_200_OK,
    summary="User login",
    description="Authenticate with email and password. Rate limited to 5 attempts per 15 minutes per email."
)
async def login(
    login_data: LoginRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    Authenticate user and return JWT token.

    - **email**: Registered email address (case-insensitive)
    - **password**: User password

    **Rate Limiting:** 5 attempts per 15 minutes per email address.
    After 5 failed attempts, returns 429 with retry_after_seconds.

    **Security:** Returns generic "Invalid email or password" message
    to prevent user enumeration attacks.
    """
    # Check rate limit (5 attempts per 15 minutes)
    rate_limit_key = f"rate_limit:login:{login_data.email.lower()}"
    is_allowed, retry_after = await check_rate_limit(
        rate_limit_key,
        max_attempts=5,
        window_seconds=900  # 15 minutes
    )

    if not is_allowed:
        raise RateLimitError(
            "Too many login attempts. Please try again later.",
            retry_after_seconds=retry_after
        )

    # Initialize repository and service
    user_repo = UserRepository(db)
    auth_service = AuthService(user_repo)

    # Authenticate user
    user, token = await auth_service.login_user(login_data.email, login_data.password)

    # Reset rate limit on successful login
    await reset_rate_limit(rate_limit_key)

    # Return response
    return LoginResponse(
        user=UserResponse.from_orm(user),
        token=token
    )
```

### Docker Compose Configuration

```yaml
# infrastructure/docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: learnr_user
      POSTGRES_PASSWORD: dev_password
      POSTGRES_DB: learnr_dev
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7.2-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Unit Tests:**

```python
# tests/unit/test_rate_limit.py
import pytest
from apps.api.src.utils.rate_limit import check_rate_limit, reset_rate_limit, get_remaining_attempts
from apps.api.src.db.redis_client import get_redis

@pytest.mark.asyncio
async def test_rate_limit_allows_under_threshold():
    """Test rate limit allows requests under threshold."""
    key = "test:rate_limit:user1"

    # First 5 attempts should be allowed
    for i in range(5):
        is_allowed, _ = await check_rate_limit(key, max_attempts=5, window_seconds=60)
        assert is_allowed is True

    # Cleanup
    redis = await get_redis()
    await redis.delete(key)

@pytest.mark.asyncio
async def test_rate_limit_blocks_over_threshold():
    """Test rate limit blocks requests over threshold."""
    key = "test:rate_limit:user2"

    # First 5 attempts allowed
    for i in range(5):
        await check_rate_limit(key, max_attempts=5, window_seconds=60)

    # 6th attempt should be blocked
    is_allowed, retry_after = await check_rate_limit(key, max_attempts=5, window_seconds=60)
    assert is_allowed is False
    assert retry_after > 0

    # Cleanup
    redis = await get_redis()
    await redis.delete(key)

@pytest.mark.asyncio
async def test_rate_limit_reset():
    """Test rate limit can be reset."""
    key = "test:rate_limit:user3"

    # Make some requests
    await check_rate_limit(key, max_attempts=5, window_seconds=60)
    await check_rate_limit(key, max_attempts=5, window_seconds=60)

    # Reset
    await reset_rate_limit(key)

    # Should be able to make requests again
    remaining = await get_remaining_attempts(key, max_attempts=5)
    assert remaining == 5
```

```python
# tests/unit/test_auth_service.py (add to existing)

@pytest.mark.asyncio
async def test_login_success(mock_user_repo):
    """Test successful login with valid credentials."""
    # Mock user
    mock_user = User(
        id=uuid.uuid4(),
        email="test@example.com",
        hashed_password=hash_password("SecurePass123")
    )
    mock_user_repo.get_by_email.return_value = mock_user

    auth_service = AuthService(mock_user_repo)
    user, token = await auth_service.login_user("test@example.com", "SecurePass123")

    assert user.email == "test@example.com"
    assert len(token) > 0

    # Verify JWT token
    payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
    assert payload["sub"] == str(mock_user.id)

@pytest.mark.asyncio
async def test_login_invalid_password(mock_user_repo):
    """Test login failure with invalid password."""
    mock_user = User(
        id=uuid.uuid4(),
        email="test@example.com",
        hashed_password=hash_password("CorrectPass123")
    )
    mock_user_repo.get_by_email.return_value = mock_user

    auth_service = AuthService(mock_user_repo)

    with pytest.raises(AuthenticationError) as exc_info:
        await auth_service.login_user("test@example.com", "WrongPass456")

    assert "Invalid email or password" in str(exc_info.value)

@pytest.mark.asyncio
async def test_login_nonexistent_email(mock_user_repo):
    """Test login failure with non-existent email."""
    mock_user_repo.get_by_email.return_value = None

    auth_service = AuthService(mock_user_repo)

    with pytest.raises(AuthenticationError) as exc_info:
        await auth_service.login_user("nonexistent@example.com", "AnyPass123")

    assert "Invalid email or password" in str(exc_info.value)

@pytest.mark.asyncio
async def test_login_generic_error_message(mock_user_repo):
    """Test that error messages are generic for security."""
    # Test wrong password
    mock_user = User(
        id=uuid.uuid4(),
        email="test@example.com",
        hashed_password=hash_password("CorrectPass123")
    )
    mock_user_repo.get_by_email.return_value = mock_user

    auth_service = AuthService(mock_user_repo)

    try:
        await auth_service.login_user("test@example.com", "WrongPass")
    except AuthenticationError as e:
        wrong_password_message = e.message

    # Test non-existent email
    mock_user_repo.get_by_email.return_value = None

    try:
        await auth_service.login_user("nonexistent@example.com", "AnyPass")
    except AuthenticationError as e:
        nonexistent_email_message = e.message

    # Messages should be identical
    assert wrong_password_message == nonexistent_email_message
```

**Integration Tests:**

```python
# tests/integration/test_auth_api.py (add to existing)

@pytest.mark.asyncio
async def test_login_success(async_client: AsyncClient, db_session):
    """Test successful login returns user and token."""
    # Register user first
    await async_client.post(
        "/v1/auth/register",
        json={"email": "logintest@example.com", "password": "SecurePass123"}
    )

    # Login
    response = await async_client.post(
        "/v1/auth/login",
        json={"email": "logintest@example.com", "password": "SecurePass123"}
    )

    assert response.status_code == 200
    data = response.json()

    assert "user" in data
    assert "token" in data
    assert data["user"]["email"] == "logintest@example.com"

    # Verify JWT token
    token = data["token"]
    payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
    assert payload["sub"] == data["user"]["id"]

@pytest.mark.asyncio
async def test_login_wrong_password(async_client: AsyncClient, db_session):
    """Test login with wrong password returns 401."""
    # Register user
    await async_client.post(
        "/v1/auth/register",
        json={"email": "wrongpass@example.com", "password": "CorrectPass123"}
    )

    # Try login with wrong password
    response = await async_client.post(
        "/v1/auth/login",
        json={"email": "wrongpass@example.com", "password": "WrongPass456"}
    )

    assert response.status_code == 401
    data = response.json()
    assert "error" in data
    assert data["error"]["code"] == "AUTHENTICATION_ERROR"
    assert data["error"]["message"] == "Invalid email or password"

@pytest.mark.asyncio
async def test_login_nonexistent_email(async_client: AsyncClient):
    """Test login with non-existent email returns 401."""
    response = await async_client.post(
        "/v1/auth/login",
        json={"email": "notregistered@example.com", "password": "AnyPass123"}
    )

    assert response.status_code == 401
    data = response.json()
    assert data["error"]["message"] == "Invalid email or password"

@pytest.mark.asyncio
async def test_login_case_insensitive_email(async_client: AsyncClient, db_session):
    """Test login works with different email case."""
    # Register with lowercase
    await async_client.post(
        "/v1/auth/register",
        json={"email": "casetest@example.com", "password": "SecurePass123"}
    )

    # Login with uppercase
    response = await async_client.post(
        "/v1/auth/login",
        json={"email": "CaseTest@Example.COM", "password": "SecurePass123"}
    )

    assert response.status_code == 200

@pytest.mark.asyncio
async def test_login_rate_limiting(async_client: AsyncClient, db_session):
    """Test rate limiting blocks after 5 failed attempts."""
    email = "ratelimit@example.com"

    # Register user
    await async_client.post(
        "/v1/auth/register",
        json={"email": email, "password": "CorrectPass123"}
    )

    # Make 5 failed login attempts
    for i in range(5):
        response = await async_client.post(
            "/v1/auth/login",
            json={"email": email, "password": f"WrongPass{i}"}
        )
        assert response.status_code == 401

    # 6th attempt should be rate limited
    response = await async_client.post(
        "/v1/auth/login",
        json={"email": email, "password": "WrongPass5"}
    )

    assert response.status_code == 429
    data = response.json()
    assert data["error"]["code"] == "RATE_LIMIT_EXCEEDED"
    assert "retry_after_seconds" in data["error"]["details"]
    assert response.headers["Retry-After"]

@pytest.mark.asyncio
async def test_login_error_messages_identical(async_client: AsyncClient, db_session):
    """Test error messages are identical for wrong password vs non-existent email."""
    # Register user
    await async_client.post(
        "/v1/auth/register",
        json={"email": "msgtest@example.com", "password": "CorrectPass123"}
    )

    # Wrong password
    response1 = await async_client.post(
        "/v1/auth/login",
        json={"email": "msgtest@example.com", "password": "WrongPass"}
    )

    # Non-existent email
    response2 = await async_client.post(
        "/v1/auth/login",
        json={"email": "nonexistent@example.com", "password": "AnyPass"}
    )

    assert response1.json()["error"]["message"] == response2.json()["error"]["message"]

@pytest.mark.asyncio
async def test_login_timing_attack_prevention(async_client: AsyncClient, db_session):
    """Test response times are similar for wrong email vs wrong password."""
    import time

    # Register user
    await async_client.post(
        "/v1/auth/register",
        json={"email": "timing@example.com", "password": "CorrectPass123"}
    )

    # Measure wrong password timing
    start = time.time()
    await async_client.post(
        "/v1/auth/login",
        json={"email": "timing@example.com", "password": "WrongPass"}
    )
    wrong_password_time = time.time() - start

    # Measure non-existent email timing
    start = time.time()
    await async_client.post(
        "/v1/auth/login",
        json={"email": "nonexistent@example.com", "password": "AnyPass"}
    )
    nonexistent_email_time = time.time() - start

    # Times should be within 50ms of each other (bcrypt is slow, so 50ms tolerance)
    time_difference = abs(wrong_password_time - nonexistent_email_time)
    assert time_difference < 0.05  # 50ms tolerance
```

### Coding Standards Reminders

[Source: architecture/coding-standards.md]

- **Async/Await:** All Redis and database operations must use async/await
- **Error Handling:** Use standard error handler middleware
- **Security:** Generic error messages, timing-safe comparisons, rate limiting

### Dependencies to Add

```txt
# Add to apps/api/requirements.txt
redis==5.0.1
```

### Success Criteria Checklist

Before marking this story complete, verify:
1. ✓ POST `/v1/auth/login` endpoint exists and returns 200 on success
2. ✓ Email lookup is case-insensitive (test with different cases)
3. ✓ Password verification using bcrypt from Story 1.3 works correctly
4. ✓ Successful login returns user object and JWT token (7-day expiration)
5. ✓ Failed login (wrong password) returns 401 with "Invalid email or password"
6. ✓ Failed login (non-existent email) returns 401 with same generic message
7. ✓ JWT token structure matches registration (user_id in "sub" claim)
8. ✓ Rate limiting works: 6th attempt within 15 minutes returns 429
9. ✓ Rate limiting resets after successful login
10. ✓ Redis connection configured and working
11. ✓ Docker Compose includes Redis service
12. ✓ All unit tests pass (rate limiting, auth service)
13. ✓ All integration tests pass (login flow, rate limiting, timing attack prevention)
14. ✓ Error messages identical for wrong password vs non-existent email
15. ✓ Response times similar for both error cases (timing attack prevention)
16. ✓ FastAPI auto-docs show login endpoint at `/docs`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
