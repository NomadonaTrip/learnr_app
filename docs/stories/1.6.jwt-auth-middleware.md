# Story 1.6: JWT Authentication Middleware

## Status
Draft

## Story
**As a** backend developer,
**I want** JWT authentication middleware protecting authenticated endpoints,
**so that** only logged-in users can access protected resources.

## Acceptance Criteria
1. Middleware function `verify_jwt_token` that extracts JWT from `Authorization: Bearer {token}` header
2. Token validation: Signature valid, not expired, contains required `user_id` claim
3. On valid token: Attach `current_user` to request context (user_id, email)
4. On invalid/missing token: Return 401 Unauthorized with message "Authentication required"
5. Decorator `@require_auth` to protect routes (e.g., `@require_auth` above route handler)
6. Protected route example: GET `/api/user/profile` returns current user's profile
7. Unit tests: Valid token grants access, expired token denied, missing token denied, invalid signature denied
8. Integration test: Protected endpoint accessible with valid JWT, denied without JWT
9. Token refresh not implemented in MVP (7-day expiration sufficient)
10. Security: Token stored securely in frontend (HttpOnly cookie or secure localStorage, TBD by frontend)

## Tasks / Subtasks

- [ ] **Task 1: Create JWT Verification Utility** (AC: 1, 2)
  - [ ] Create `apps/api/src/utils/jwt.py` (or extend existing `auth.py`)
  - [ ] Implement `def decode_token(token: str) -> dict | None` to decode and validate JWT
  - [ ] Verify signature using JWT_SECRET_KEY from config
  - [ ] Check token expiration
  - [ ] Verify required claims (sub for user_id)
  - [ ] Handle JWT decode errors (ExpiredSignatureError, InvalidTokenError)

- [ ] **Task 2: Create Authentication Dependency** (AC: 1, 3, 4)
  - [ ] Create `apps/api/src/dependencies.py`
  - [ ] Implement `async def get_current_user(authorization: str | None = Header(None)) -> User`
  - [ ] Extract token from Authorization header (Bearer scheme)
  - [ ] Decode and validate token
  - [ ] Look up user from database using user_id from token
  - [ ] Return User object
  - [ ] Raise HTTPException 401 if token missing, invalid, expired, or user not found

- [ ] **Task 3: Create Optional Authentication Dependency** (AC: 3)
  - [ ] Create `async def get_current_user_optional() -> User | None`
  - [ ] Same logic as get_current_user but returns None instead of raising exception
  - [ ] Useful for endpoints that work with or without authentication

- [ ] **Task 4: Create User Profile Endpoint** (AC: 6)
  - [ ] Create `apps/api/src/routes/users.py`
  - [ ] Define `GET /v1/users/me` endpoint
  - [ ] Use `current_user = Depends(get_current_user)` for authentication
  - [ ] Return UserResponse schema with current user data
  - [ ] Register users router in main.py

- [ ] **Task 5: Create User Profile Update Endpoint** (AC: 6)
  - [ ] Define `PUT /v1/users/me` endpoint in users.py
  - [ ] Accept UserUpdate schema (from Story 1.2)
  - [ ] Use `current_user = Depends(get_current_user)` for authentication
  - [ ] Update user profile fields (exam_date, target_score, etc.)
  - [ ] Return updated UserResponse

- [ ] **Task 6: Add Authorization Error Handler** (AC: 4)
  - [ ] Add `AuthorizationError` exception to exceptions.py (401 status)
  - [ ] Create exception handler returning "Authentication required" message
  - [ ] Register handler in main.py

- [ ] **Task 7: Write Unit Tests for JWT Verification** (AC: 7)
  - [ ] Create `apps/api/tests/unit/test_jwt.py`
  - [ ] Test decode_token with valid token
  - [ ] Test decode_token with expired token
  - [ ] Test decode_token with invalid signature
  - [ ] Test decode_token with malformed token
  - [ ] Test decode_token with missing required claims

- [ ] **Task 8: Write Unit Tests for Authentication Dependency** (AC: 7)
  - [ ] Create `apps/api/tests/unit/test_dependencies.py`
  - [ ] Test get_current_user with valid token and existing user
  - [ ] Test get_current_user with missing Authorization header
  - [ ] Test get_current_user with invalid token
  - [ ] Test get_current_user with valid token but non-existent user

- [ ] **Task 9: Write Integration Tests** (AC: 8)
  - [ ] Update `apps/api/tests/integration/test_auth_api.py`
  - [ ] Test GET /v1/users/me with valid JWT returns user profile
  - [ ] Test GET /v1/users/me without token returns 401
  - [ ] Test GET /v1/users/me with expired token returns 401
  - [ ] Test GET /v1/users/me with invalid token returns 401
  - [ ] Test PUT /v1/users/me with valid JWT updates profile
  - [ ] Test PUT /v1/users/me without token returns 401

- [ ] **Task 10: Update API Documentation** (AC: 6)
  - [ ] Add docstrings to user endpoints
  - [ ] Verify FastAPI auto-docs shows protected endpoints with lock icon
  - [ ] Document Authorization header requirement in endpoint descriptions

- [ ] **Task 11: Create Pydantic Schema for Current User** (AC: 3)
  - [ ] Create CurrentUser model in schemas if needed
  - [ ] Or reuse User model from database
  - [ ] Ensure user_id and email are accessible

## Dev Notes

### Previous Story Context

From **Story 1.1** (relevant learnings):
- Backend structure established with routes, services, repositories pattern

From **Story 1.2** (relevant learnings):
- User model with id, email, and profile fields
- UserRepository with get_by_id() method
- UserUpdate schema for profile updates

From **Story 1.3** (relevant learnings):
- JWT token creation: `create_access_token()` utility
- JWT configuration: SECRET_KEY, ALGORITHM, 7-day expiration
- UserResponse schema for returning user data

From **Story 1.4** (relevant learnings):
- Login returns JWT token
- Exception handling framework

From **Story 1.5** (relevant learnings):
- Password reset flow, user lookup patterns

### API Endpoint Specifications

#### Get Current User Profile

**Endpoint:** `GET /v1/users/me` [Source: architecture/api-specification.md]

**Authentication:** Required - JWT token in Authorization header

**Request Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Success Response (200 OK):**
```json
{
  "id": "uuid-here",
  "email": "user@example.com",
  "created_at": "2025-11-21T10:30:00Z",
  "exam_date": "2025-12-15",
  "target_score": 85,
  "daily_study_time": 60,
  "knowledge_level": "Intermediate",
  "motivation": "Career advancement",
  "referral_source": "Search",
  "is_admin": false,
  "dark_mode": "dark"
}
```

**Error Response (401 Unauthorized):**
```json
{
  "error": {
    "code": "AUTHENTICATION_ERROR",
    "message": "Authentication required",
    "details": {},
    "timestamp": "2025-11-21T10:30:00Z",
    "request_id": "req_abc123"
  }
}
```

#### Update Current User Profile

**Endpoint:** `PUT /v1/users/me` [Source: architecture/api-specification.md]

**Authentication:** Required - JWT token in Authorization header

**Request Body:**
```json
{
  "exam_date": "2025-12-15",
  "target_score": 85,
  "daily_study_time": 60,
  "knowledge_level": "Intermediate",
  "motivation": "Career advancement",
  "referral_source": "Search",
  "dark_mode": "dark"
}
```

**Success Response (200 OK):**
Same as GET /v1/users/me (updated user object)

### JWT Token Decoding

**Token Payload Structure:** [Source: Story 1.3]
```json
{
  "sub": "user_id_uuid",
  "exp": 1732790400,
  "iat": 1732186800
}
```

**JWT Verification Implementation:**
```python
# apps/api/src/utils/jwt.py (or extend auth.py)
from jose import jwt, JWTError, ExpiredSignatureError
from apps.api.src.config import settings
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

def decode_token(token: str) -> dict | None:
    """
    Decode and validate JWT token.

    Args:
        token: JWT token string

    Returns:
        Token payload dict if valid, None otherwise
    """
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )

        # Verify required claims
        if "sub" not in payload:
            logger.warning("Token missing 'sub' claim")
            return None

        return payload

    except ExpiredSignatureError:
        logger.info("Token expired")
        return None
    except JWTError as e:
        logger.warning(f"Invalid token: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error decoding token: {str(e)}")
        return None
```

### Authentication Dependency (FastAPI Dependency Injection)

**FastAPI Dependency Pattern:** [Source: architecture/backend-architecture.md#Authentication]

```python
# apps/api/src/dependencies.py
from fastapi import Depends, HTTPException, status, Header
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from apps.api.src.db.session import get_db
from apps.api.src.repositories.user_repository import UserRepository
from apps.api.src.utils.jwt import decode_token
from apps.api.src.models.user import User

async def get_current_user(
    authorization: str | None = Header(None, alias="Authorization"),
    db: AsyncSession = Depends(get_db)
) -> User:
    """
    Dependency to get current authenticated user from JWT token.

    Extracts JWT from Authorization header, validates it, and returns User object.

    Args:
        authorization: Authorization header value (Bearer {token})
        db: Database session

    Returns:
        User object

    Raises:
        HTTPException 401: If token missing, invalid, expired, or user not found
    """
    # Check Authorization header exists
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Extract token from "Bearer {token}" format
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header format. Expected: Bearer {token}",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = parts[1]

    # Decode and validate token
    payload = decode_token(token)
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Extract user_id from token
    user_id_str = payload.get("sub")
    if not user_id_str:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: missing user identifier",
            headers={"WWW-Authenticate": "Bearer"},
        )

    try:
        user_id = UUID(user_id_str)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: malformed user identifier",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Look up user in database
    user_repo = UserRepository(db)
    user = await user_repo.get_by_id(user_id)

    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return user

async def get_current_user_optional(
    authorization: str | None = Header(None, alias="Authorization"),
    db: AsyncSession = Depends(get_db)
) -> User | None:
    """
    Optional authentication dependency.

    Returns User if valid token provided, None otherwise.
    Does not raise exceptions for missing/invalid tokens.

    Useful for endpoints that work with or without authentication.

    Args:
        authorization: Authorization header value (Bearer {token})
        db: Database session

    Returns:
        User object if authenticated, None otherwise
    """
    try:
        return await get_current_user(authorization, db)
    except HTTPException:
        return None
```

### User Profile Endpoints

```python
# apps/api/src/routes/users.py
from fastapi import APIRouter, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession

from apps.api.src.db.session import get_db
from apps.api.src.dependencies import get_current_user
from apps.api.src.schemas.user import UserResponse, UserUpdate
from apps.api.src.models.user import User
from apps.api.src.repositories.user_repository import UserRepository

router = APIRouter(prefix="/users", tags=["users"])

@router.get(
    "/me",
    response_model=UserResponse,
    status_code=status.HTTP_200_OK,
    summary="Get current user profile",
    description="Get authenticated user's profile information. Requires valid JWT token."
)
async def get_user_profile(
    current_user: User = Depends(get_current_user)
):
    """
    Get current authenticated user's profile.

    **Authentication Required:** JWT token in Authorization header.

    Returns complete user profile including onboarding data.
    """
    return UserResponse.from_orm(current_user)

@router.put(
    "/me",
    response_model=UserResponse,
    status_code=status.HTTP_200_OK,
    summary="Update current user profile",
    description="Update authenticated user's profile and onboarding data. Requires valid JWT token."
)
async def update_user_profile(
    user_data: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Update current authenticated user's profile.

    **Authentication Required:** JWT token in Authorization header.

    Allows updating onboarding fields:
    - exam_date
    - target_score
    - daily_study_time
    - knowledge_level
    - motivation
    - referral_source
    - dark_mode

    Returns updated user profile.
    """
    user_repo = UserRepository(db)

    # Update user fields
    update_data = user_data.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(current_user, field, value)

    await db.commit()
    await db.refresh(current_user)

    return UserResponse.from_orm(current_user)
```

**Register router in main.py:**
```python
# apps/api/src/main.py
from apps.api.src.routes import auth, users

# Existing code...

# Register routers with /v1 prefix
app.include_router(auth.router, prefix="/v1")
app.include_router(users.router, prefix="/v1")  # Add this line
```

### FastAPI Security Documentation

**OpenAPI Security Scheme:** [Source: architecture/api-specification.md]

FastAPI automatically generates security documentation when using dependency injection with proper configuration.

```python
# apps/api/src/main.py
from fastapi import FastAPI
from fastapi.security import HTTPBearer

app = FastAPI(
    title="LearnR API",
    version="1.0.0",
    description="CBAP Certification Preparation Platform API"
)

# Configure HTTP Bearer security for OpenAPI docs
security = HTTPBearer()

# This makes protected endpoints show lock icon in /docs
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Unit Tests:**

```python
# tests/unit/test_jwt.py
import pytest
from datetime import datetime, timedelta
from jose import jwt
from apps.api.src.utils.jwt import decode_token
from apps.api.src.config import settings

def test_decode_valid_token():
    """Test decoding valid JWT token."""
    payload = {
        "sub": "123e4567-e89b-12d3-a456-426614174000",
        "exp": datetime.utcnow() + timedelta(days=1),
        "iat": datetime.utcnow()
    }
    token = jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)

    decoded = decode_token(token)

    assert decoded is not None
    assert decoded["sub"] == payload["sub"]

def test_decode_expired_token():
    """Test decoding expired token returns None."""
    payload = {
        "sub": "123e4567-e89b-12d3-a456-426614174000",
        "exp": datetime.utcnow() - timedelta(days=1),  # Expired yesterday
        "iat": datetime.utcnow() - timedelta(days=2)
    }
    token = jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)

    decoded = decode_token(token)

    assert decoded is None

def test_decode_invalid_signature():
    """Test decoding token with invalid signature returns None."""
    payload = {
        "sub": "123e4567-e89b-12d3-a456-426614174000",
        "exp": datetime.utcnow() + timedelta(days=1),
        "iat": datetime.utcnow()
    }
    # Sign with wrong secret
    token = jwt.encode(payload, "wrong_secret_key", algorithm=settings.JWT_ALGORITHM)

    decoded = decode_token(token)

    assert decoded is None

def test_decode_malformed_token():
    """Test decoding malformed token returns None."""
    decoded = decode_token("not.a.valid.token")

    assert decoded is None

def test_decode_token_missing_sub_claim():
    """Test decoding token without required 'sub' claim returns None."""
    payload = {
        "exp": datetime.utcnow() + timedelta(days=1),
        "iat": datetime.utcnow()
        # Missing 'sub' claim
    }
    token = jwt.encode(payload, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)

    decoded = decode_token(token)

    assert decoded is None
```

```python
# tests/unit/test_dependencies.py
import pytest
from fastapi import HTTPException
from apps.api.src.dependencies import get_current_user
from apps.api.src.utils.jwt import create_access_token

@pytest.mark.asyncio
async def test_get_current_user_valid_token(mock_db_session, mock_user):
    """Test get_current_user with valid token and existing user."""
    # Create valid token
    token = create_access_token(data={"sub": str(mock_user.id)})
    authorization = f"Bearer {token}"

    # Mock user repository
    mock_user_repo = MagicMock()
    mock_user_repo.get_by_id.return_value = mock_user

    user = await get_current_user(authorization, mock_db_session)

    assert user.id == mock_user.id
    assert user.email == mock_user.email

@pytest.mark.asyncio
async def test_get_current_user_missing_header(mock_db_session):
    """Test get_current_user without Authorization header raises 401."""
    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(None, mock_db_session)

    assert exc_info.value.status_code == 401
    assert "Authentication required" in str(exc_info.value.detail)

@pytest.mark.asyncio
async def test_get_current_user_invalid_token(mock_db_session):
    """Test get_current_user with invalid token raises 401."""
    authorization = "Bearer invalid.token.here"

    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(authorization, mock_db_session)

    assert exc_info.value.status_code == 401

@pytest.mark.asyncio
async def test_get_current_user_user_not_found(mock_db_session):
    """Test get_current_user with valid token but non-existent user raises 401."""
    token = create_access_token(data={"sub": str(uuid.uuid4())})
    authorization = f"Bearer {token}"

    # Mock user repository returning None
    mock_user_repo = MagicMock()
    mock_user_repo.get_by_id.return_value = None

    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(authorization, mock_db_session)

    assert exc_info.value.status_code == 401
    assert "User not found" in str(exc_info.value.detail)
```

**Integration Tests:**

```python
# tests/integration/test_auth_api.py (add to existing)

@pytest.mark.asyncio
async def test_get_user_profile_authenticated(async_client: AsyncClient, db_session):
    """Test GET /v1/users/me with valid JWT returns profile."""
    # Register and login
    register_response = await async_client.post(
        "/v1/auth/register",
        json={"email": "profiletest@example.com", "password": "SecurePass123"}
    )
    token = register_response.json()["token"]

    # Get profile
    response = await async_client.get(
        "/v1/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )

    assert response.status_code == 200
    data = response.json()
    assert data["email"] == "profiletest@example.com"
    assert "id" in data
    assert "created_at" in data

@pytest.mark.asyncio
async def test_get_user_profile_no_token(async_client: AsyncClient):
    """Test GET /v1/users/me without token returns 401."""
    response = await async_client.get("/v1/users/me")

    assert response.status_code == 401
    assert "Authentication required" in response.json()["error"]["message"]

@pytest.mark.asyncio
async def test_get_user_profile_expired_token(async_client: AsyncClient):
    """Test GET /v1/users/me with expired token returns 401."""
    # Create expired token
    expired_token = create_access_token(
        data={"sub": str(uuid.uuid4())},
        expires_delta=timedelta(seconds=-1)  # Expired 1 second ago
    )

    response = await async_client.get(
        "/v1/users/me",
        headers={"Authorization": f"Bearer {expired_token}"}
    )

    assert response.status_code == 401

@pytest.mark.asyncio
async def test_get_user_profile_invalid_token(async_client: AsyncClient):
    """Test GET /v1/users/me with invalid token returns 401."""
    response = await async_client.get(
        "/v1/users/me",
        headers={"Authorization": "Bearer invalid.token.here"}
    )

    assert response.status_code == 401

@pytest.mark.asyncio
async def test_update_user_profile_authenticated(async_client: AsyncClient, db_session):
    """Test PUT /v1/users/me with valid JWT updates profile."""
    # Register and login
    register_response = await async_client.post(
        "/v1/auth/register",
        json={"email": "updatetest@example.com", "password": "SecurePass123"}
    )
    token = register_response.json()["token"]

    # Update profile
    response = await async_client.put(
        "/v1/users/me",
        headers={"Authorization": f"Bearer {token}"},
        json={
            "exam_date": "2025-12-15",
            "target_score": 85,
            "daily_study_time": 60,
            "knowledge_level": "Intermediate",
            "dark_mode": "dark"
        }
    )

    assert response.status_code == 200
    data = response.json()
    assert data["exam_date"] == "2025-12-15"
    assert data["target_score"] == 85
    assert data["daily_study_time"] == 60
    assert data["knowledge_level"] == "Intermediate"
    assert data["dark_mode"] == "dark"

@pytest.mark.asyncio
async def test_update_user_profile_no_token(async_client: AsyncClient):
    """Test PUT /v1/users/me without token returns 401."""
    response = await async_client.put(
        "/v1/users/me",
        json={"target_score": 85}
    )

    assert response.status_code == 401

@pytest.mark.asyncio
async def test_protected_endpoint_workflow(async_client: AsyncClient, db_session):
    """Test complete workflow: register → login → access protected endpoint."""
    # Register
    register_response = await async_client.post(
        "/v1/auth/register",
        json={"email": "workflow@example.com", "password": "SecurePass123"}
    )
    assert register_response.status_code == 201

    # Login
    login_response = await async_client.post(
        "/v1/auth/login",
        json={"email": "workflow@example.com", "password": "SecurePass123"}
    )
    assert login_response.status_code == 200
    token = login_response.json()["token"]

    # Access protected endpoint
    profile_response = await async_client.get(
        "/v1/users/me",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert profile_response.status_code == 200
    assert profile_response.json()["email"] == "workflow@example.com"
```

### Coding Standards Reminders

[Source: architecture/coding-standards.md]

- **Async/Await:** All database operations must use async/await
- **Dependency Injection:** Use FastAPI Depends() for authentication
- **Error Handling:** Return consistent 401 errors with WWW-Authenticate header
- **Security:** Never expose sensitive information in error messages

### Success Criteria Checklist

Before marking this story complete, verify:
1. ✓ JWT token extraction from Authorization header works
2. ✓ Token validation checks signature, expiration, and required claims
3. ✓ Current user attached to request via dependency injection
4. ✓ Invalid/missing/expired tokens return 401 with "Authentication required"
5. ✓ `get_current_user` dependency works as @Depends decorator
6. ✓ GET `/v1/users/me` endpoint returns authenticated user profile
7. ✓ PUT `/v1/users/me` endpoint updates user profile
8. ✓ All unit tests pass (JWT decoding, dependency logic)
9. ✓ All integration tests pass (protected endpoints accessible with token, denied without)
10. ✓ FastAPI auto-docs shows protected endpoints with lock icon
11. ✓ WWW-Authenticate header included in 401 responses
12. ✓ Token refresh not implemented (documented as future enhancement)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
